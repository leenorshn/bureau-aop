# GraphQL Schema for MLM Backend

type Product {
  id: ID!
  name: String!
  description: String!
  price: Float!
  stock: Int!
  points: Float!
  imageUrl: String!
  createdAt: String!
  updatedAt: String!
}

type Client {
  id: ID!
  clientId: String!
  name: String!
  phone:String
  nn:String
  address:String
  avatar:String
  sponsorId: ID
  position: String
  leftChildId: ID
  rightChildId: ID
  joinDate: String!
  totalEarnings: Float!
  walletBalance: Float!
  points: Float!
  networkVolumeLeft: Float!
  networkVolumeRight: Float!
  binaryPairs: Int!
  sponsor: Client
  leftChild: Client
  rightChild: Client
  transactions: [Payment!]!
  purchases: [Sale!]!
}

type Sale {
  id: ID!
  clientId: ID!
  sponsorId: ID!
  productId: ID
  amount: Float!
  quantity: Int!
  side: String
  date: String!
  status: String!
  note: String
  client: Client
  sponsor: Client
  product: Product
}

type Payment {
  id: ID!
  clientId: ID!
  amount: Float!
  date: String!
  method: String!
  status: String!
  description: String
  client: Client
}

type Commission {
  id: ID!
  clientId: ID!
  sourceClientId: ID!
  amount: Float!
  level: Int!
  type: String!
  date: String!
  client: Client
  sourceClient: Client
}

type Caisse {
  id: ID!
  balance: Float!
  totalEntrees: Float!
  totalSorties: Float!
  createdAt: String!
  updatedAt: String!
  transactions: [CaisseTransaction!]!
}

type CaisseTransaction {
  id: ID!
  type: String! # "entree" ou "sortie"
  amount: Float!
  description: String
  reference: String # ID de la vente ou paiement associé
  referenceType: String # "sale", "payment", "manual"
  date: String!
  createdBy: String
}

type User {
  id: ID!
  name: String!
  email: String!
  role: String!
  createdAt: String!
}

type DashboardStats {
  # KPIs principaux
  totalProducts: Int!
  totalClients: Int!
  totalSales: Float!
  totalRevenue: Float!
  activeClients: Int!
  
  # Statistiques du réseau binaire
  leftVolume: Float!
  rightVolume: Float!
  binaryPairs: Int!
  totalCommissions: Float!
  
  # Équilibre du réseau
  networkBalance: Float!
  
  # Données détaillées
  monthlySales: [MonthlySales!]!
  networkGrowth: [NetworkGrowth!]!
  salesStatus: SalesStatus!
  topProducts: [TopProduct!]!
  recentActivity: [RecentActivity!]!
}

type MonthlySales {
  month: String!
  sales: Float!
  revenue: Float!
}

type NetworkGrowth {
  month: String!
  newClients: Int!
  totalClients: Int!
}

type SalesStatus {
  paid: Float!
  pending: Float!
  partial: Float!
}

type TopProduct {
  name: String!
  sales: Int!
}

type RecentActivity {
  id: ID!
  type: String!
  description: String!
  date: String!
  amount: Float
}

type AuthPayload {
  accessToken: String!
  refreshToken: String!
  user: User!
}

type CommissionResult {
  commissionsCreated: Int!
  totalAmount: Float!
  message: String!
}

input ProductInput {
  name: String!
  description: String!
  price: Float!
  stock: Int!
  points: Float!
  imageUrl: String!
}

input ClientInput {
  name: String!
  password: String!
  position: String
  sponsorId: ID 
  phone:String
  nn:String
  address:String
  avatar:String
}

input SaleInput {
  clientId: ID!
  productId: ID!
  quantity: Int!
  amount: Float!
  status: String
  note: String
}

input PaymentInput {
  clientId: ID!
  amount: Float!
  method: String!
  description: String
}

input CommissionInput {
  clientId: ID!
  sourceClientId: ID!
  amount: Float!
  level: Int!
  type: String!
}

input LoginInput {
  email: String!
  password: String!
}

input ClientLoginInput {
  clientId: String!
  password: String!
}

input RefreshTokenInput {
  token: String!
}

input CaisseTransactionInput {
  type: String! # "entree" ou "sortie"
  amount: Float!
  description: String
  reference: String
  referenceType: String # "sale", "payment", "manual"
}

input FilterInput {
  search: String
  dateFrom: String
  dateTo: String
  status: String
}

input PagingInput {
  page: Int
  limit: Int
}

type Query {
  me:User

  # Products
  products(filter: FilterInput, paging: PagingInput): [Product!]!
  product(id: ID!): Product

  # Clients
  clients(filter: FilterInput, paging: PagingInput): [Client!]!
  client(id: ID!): Client

  # Sales
  sales(filter: FilterInput, paging: PagingInput): [Sale!]!
  sale(id: ID!): Sale

  # Payments
  payments(filter: FilterInput, paging: PagingInput): [Payment!]!
  payment(id: ID!): Payment

  # Commissions
  commissions(filter: FilterInput, paging: PagingInput): [Commission!]!
  commission(id: ID!): Commission

  # Dashboard
  dashboardStats(range: String): DashboardStats!
  dashboardData: DashboardStats!

  # Caisse
  caisse: Caisse!
  caisseTransactions(filter: FilterInput, paging: PagingInput): [CaisseTransaction!]!
}

type Mutation {
  # Authentication
  userLogin(input: LoginInput!): AuthPayload!
  clientLogin(input: ClientLoginInput!): AuthPayload!
  refreshToken(input: RefreshTokenInput!): AuthPayload!

  # Products
  productCreate(input: ProductInput!): Product!
  productUpdate(id: ID!, input: ProductInput!): Product!
  productDelete(id: ID!): Boolean!

  # Clients
  clientCreate(input: ClientInput!): Client!
  clientUpdate(id: ID!, input: ClientInput!): Client!
  clientDelete(id: ID!): Boolean!

  # Sales
  saleCreate(input: SaleInput!): Sale!
  saleUpdate(id: ID!, input: SaleInput!): Sale!
  saleDelete(id: ID!): Boolean!

  # Payments
  paymentCreate(input: PaymentInput!): Payment!
  paymentUpdate(id: ID!, input: PaymentInput!): Payment!
  paymentDelete(id: ID!): Boolean!

  # Commissions
  commissionManualCreate(input: CommissionInput!): Commission!

  # MLM Operations
  runBinaryCommissionCheck(clientId: ID!): CommissionResult!

  # Caisse
  caisseAddTransaction(input: CaisseTransactionInput!): CaisseTransaction!
  caisseUpdateBalance(balance: Float!): Caisse!
}

type Subscription {
  onNewSale: Sale!
  onNewCommission: Commission!
}

