package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"bureau/graph/model"
	"bureau/internal/models"
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// UserLogin is the resolver for the userLogin field.
func (r *mutationResolver) UserLogin(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	ap, err := r.Resolver.authService.AdminLogin(ctx, input.Email, input.Password)
	if err != nil {
		return nil, err
	}
	user := &model.User{
		ID:    ap.Admin.ID.Hex(),
		Name:  ap.Admin.Name,
		Email: ap.Admin.Email,
		Role:  ap.Admin.Role,
		// CreatedAt omitted for brevity
	}
	return &model.AuthPayload{AccessToken: ap.AccessToken, RefreshToken: ap.RefreshToken, User: user}, nil
}

// ClientLogin is the resolver for the clientLogin field.
func (r *mutationResolver) ClientLogin(ctx context.Context, input model.ClientLoginInput) (*model.AuthPayload, error) {
	// Authenticate client by clientId/password
	c, err := r.Resolver.clientService.AuthenticateClient(ctx, input.ClientID, input.Password)
	if err != nil {
		return nil, err
	}
	// Generate client JWT tokens
	jwt := r.Resolver.authService.GetJWTService()
	access, err := jwt.GenerateClientAccessToken(c)
	if err != nil {
		return nil, err
	}
	refresh, err := jwt.GenerateClientRefreshToken(c)
	if err != nil {
		return nil, err
	}
	return &model.AuthPayload{
		AccessToken:  access,
		RefreshToken: refresh,
		User: &model.User{
			ID:        c.ID.Hex(),
			Name:      c.Name,
			Email:     "",
			Role:      "client",
			CreatedAt: "",
		},
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, input model.RefreshTokenInput) (*model.AuthPayload, error) {
	ap, err := r.Resolver.authService.RefreshToken(ctx, input.Token)
	if err != nil {
		return nil, err
	}
	user := &model.User{
		ID:    ap.Admin.ID.Hex(),
		Name:  ap.Admin.Name,
		Email: ap.Admin.Email,
		Role:  ap.Admin.Role,
	}
	return &model.AuthPayload{AccessToken: ap.AccessToken, RefreshToken: ap.RefreshToken, User: user}, nil
}

// ProductCreate is the resolver for the productCreate field.
func (r *mutationResolver) ProductCreate(ctx context.Context, input model.ProductInput) (*model.Product, error) {
	now := time.Now()
	p := &models.Product{
		Name:        input.Name,
		Description: input.Description,
		Price:       input.Price,
		Stock:       int(input.Stock),
		Points:      input.Points,
		ImageURL:    input.ImageURL,
		CreatedAt:   now,
		UpdatedAt:   now,
	}
	created, err := r.Resolver.productService.Create(ctx, p)
	if err != nil {
		return nil, err
	}
	return &model.Product{
		ID:          created.ID.Hex(),
		Name:        created.Name,
		Description: created.Description,
		Price:       created.Price,
		Stock:       int32(created.Stock),
		Points:      created.Points,
		ImageURL:    created.ImageURL,
		CreatedAt:   created.CreatedAt.Format(time.RFC3339),
		UpdatedAt:   created.UpdatedAt.Format(time.RFC3339),
	}, nil
}

// ProductUpdate is the resolver for the productUpdate field.
func (r *mutationResolver) ProductUpdate(ctx context.Context, id string, input model.ProductInput) (*model.Product, error) {
	now := time.Now()
	p := &models.Product{
		Name:        input.Name,
		Description: input.Description,
		Price:       input.Price,
		Stock:       int(input.Stock),
		Points:      input.Points,
		ImageURL:    input.ImageURL,
		UpdatedAt:   now,
	}
	updated, err := r.Resolver.productService.Update(ctx, id, p)
	if err != nil {
		return nil, err
	}
	return &model.Product{
		ID:          updated.ID.Hex(),
		Name:        updated.Name,
		Description: updated.Description,
		Price:       updated.Price,
		Stock:       int32(updated.Stock),
		Points:      updated.Points,
		ImageURL:    updated.ImageURL,
		CreatedAt:   updated.CreatedAt.Format(time.RFC3339),
		UpdatedAt:   updated.UpdatedAt.Format(time.RFC3339),
	}, nil
}

// ProductDelete is the resolver for the productDelete field.
func (r *mutationResolver) ProductDelete(ctx context.Context, id string) (bool, error) {
	return r.Resolver.productService.Delete(ctx, id)
}

// ClientCreate is the resolver for the clientCreate field.
func (r *mutationResolver) ClientCreate(ctx context.Context, input model.ClientInput) (*model.Client, error) {
	var sponsorOID *primitive.ObjectID
	if input.SponsorID != nil {
		oid, err := primitive.ObjectIDFromHex(*input.SponsorID)
		if err == nil {
			sponsorOID = &oid
		}
	}

	var requestedPosition *string
	if input.Position != nil && *input.Position != "" {
		requestedPosition = input.Position
	}

	now := time.Now()
	m := &models.Client{
		Name:         input.Name,
		PasswordHash: input.Password, // service will hash
		Phone:        input.Phone,
		NN:           input.Nn,
		Address:      input.Address,
		Avatar:       input.Avatar,
		JoinDate:     now,
	}
	created, err := r.Resolver.clientService.CreateWithBinaryPlacement(ctx, m, sponsorOID, requestedPosition)
	if err != nil {
		return nil, err
	}
	out := &model.Client{
		ID:                 created.ID.Hex(),
		ClientID:           created.ClientID,
		Name:               created.Name,
		Phone:              created.Phone,
		Nn:                 created.NN,
		Address:            created.Address,
		Avatar:             created.Avatar,
		JoinDate:           created.JoinDate.Format(time.RFC3339),
		Position:           created.Position,
		TotalEarnings:      created.TotalEarnings,
		WalletBalance:      created.WalletBalance,
		Points:             created.Points,
		NetworkVolumeLeft:  created.NetworkVolumeLeft,
		NetworkVolumeRight: created.NetworkVolumeRight,
		BinaryPairs:        int32(created.BinaryPairs),
	}
	if created.SponsorID != nil {
		sid := created.SponsorID.Hex()
		out.SponsorID = &sid
	}
	if created.LeftChildID != nil {
		lid := created.LeftChildID.Hex()
		out.LeftChildID = &lid
	}
	if created.RightChildID != nil {
		rid := created.RightChildID.Hex()
		out.RightChildID = &rid
	}
	return out, nil
}

// ClientUpdate is the resolver for the clientUpdate field.
func (r *mutationResolver) ClientUpdate(ctx context.Context, id string, input model.ClientInput) (*model.Client, error) {
	m := &models.Client{
		Name:    input.Name,
		Phone:   input.Phone,
		NN:      input.Nn,
		Address: input.Address,
		Avatar:  input.Avatar,
	}
	updated, err := r.Resolver.clientService.Update(ctx, id, m)
	if err != nil {
		return nil, err
	}
	out := &model.Client{
		ID:                 updated.ID.Hex(),
		ClientID:           updated.ClientID,
		Name:               updated.Name,
		Phone:              updated.Phone,
		Nn:                 updated.NN,
		Address:            updated.Address,
		Avatar:             updated.Avatar,
		JoinDate:           updated.JoinDate.Format(time.RFC3339),
		Position:           updated.Position,
		TotalEarnings:      updated.TotalEarnings,
		WalletBalance:      updated.WalletBalance,
		Points:             updated.Points,
		NetworkVolumeLeft:  updated.NetworkVolumeLeft,
		NetworkVolumeRight: updated.NetworkVolumeRight,
		BinaryPairs:        int32(updated.BinaryPairs),
	}
	if updated.SponsorID != nil {
		sid := updated.SponsorID.Hex()
		out.SponsorID = &sid
	}
	if updated.LeftChildID != nil {
		lid := updated.LeftChildID.Hex()
		out.LeftChildID = &lid
	}
	if updated.RightChildID != nil {
		rid := updated.RightChildID.Hex()
		out.RightChildID = &rid
	}
	return out, nil
}

// ClientDelete is the resolver for the clientDelete field.
func (r *mutationResolver) ClientDelete(ctx context.Context, id string) (bool, error) {
	return r.Resolver.clientService.Delete(ctx, id)
}

// SaleCreate is the resolver for the saleCreate field.
func (r *mutationResolver) SaleCreate(ctx context.Context, input model.SaleInput) (*model.Sale, error) {
	// Resolve client and sponsor
	clientOID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, err
	}
	client, err := r.Resolver.clientService.GetByID(ctx, input.ClientID)
	if err != nil {
		return nil, err
	}
	sponsorOID := clientOID
	if client.SponsorID != nil {
		sponsorOID = *client.SponsorID
	}

	// Resolve product and get points
	var productOID *primitive.ObjectID
	var pointsToAdd float64
	if input.ProductID != "" {
		poid, err := primitive.ObjectIDFromHex(input.ProductID)
		if err == nil {
			productOID = &poid
			// Get product to retrieve points and check stock
			product, err := r.Resolver.productService.GetByID(ctx, input.ProductID)
			if err != nil {
				return nil, fmt.Errorf("produit introuvable: %w", err)
			}
			if product == nil {
				return nil, errors.New("produit introuvable")
			}

			// Vérifier que le stock est suffisant
			if product.Stock < int(input.Quantity) {
				return nil, fmt.Errorf("stock insuffisant: disponible %d, demandé %d", product.Stock, input.Quantity)
			}

			// Calculate points: product points * quantity
			pointsToAdd = product.Points * float64(input.Quantity)

			// Diminuer le stock du produit
			product.Stock = product.Stock - int(input.Quantity)
			_, err = r.Resolver.productService.Update(ctx, input.ProductID, product)
			if err != nil {
				return nil, fmt.Errorf("échec de la mise à jour du stock: %w", err)
			}
		}
	}

	status := "pending"
	if input.Status != nil {
		status = *input.Status
	}

	m := &models.Sale{
		ClientID:  clientOID,
		SponsorID: sponsorOID,
		ProductID: productOID,
		Amount:    input.Amount,
		Quantity:  int(input.Quantity),
		Date:      time.Now(),
		Status:    status,
		Note:      input.Note,
	}
	created, err := r.Resolver.saleService.Create(ctx, m)
	if err != nil {
		return nil, err
	}

	// Ajouter les points au client selon le produit acheté et la quantité
	// Les points = points du produit × quantité achetée
	if input.ProductID != "" && pointsToAdd > 0 {
		err = r.Resolver.clientService.AddPoints(ctx, input.ClientID, pointsToAdd)
		if err != nil {
			// Si l'ajout de points échoue, on retourne une erreur car c'est important
			return nil, fmt.Errorf("échec de l'ajout des points au client: %w", err)
		}
	}

	// Ajouter une entrée à la caisse pour cette vente (seulement si le statut est "paid")
	if created.Status == "paid" {
		saleRef := created.ID.Hex()
		refType := "sale"
		desc := fmt.Sprintf("Vente de produit - Client: %s", client.Name)
		caisseTransaction := &models.CaisseTransaction{
			Type:          "entree",
			Amount:        created.Amount,
			Description:   &desc,
			Reference:     &saleRef,
			ReferenceType: &refType,
		}
		_, err = r.Resolver.caisseService.AddTransaction(ctx, caisseTransaction)
		if err != nil {
			// Log error but don't fail the sale creation
			// In production, you might want to handle this differently
		}
	}

	var prodIdStr *string
	if created.ProductID != nil {
		s := created.ProductID.Hex()
		prodIdStr = &s
	}
	return &model.Sale{
		ID: created.ID.Hex(), ClientID: created.ClientID.Hex(), SponsorID: created.SponsorID.Hex(), ProductID: prodIdStr,
		Amount: created.Amount, Quantity: int32(created.Quantity), Side: created.Side, Date: created.Date.Format(time.RFC3339), Status: created.Status, Note: created.Note,
	}, nil
}

// SaleUpdate is the resolver for the saleUpdate field.
func (r *mutationResolver) SaleUpdate(ctx context.Context, id string, input model.SaleInput) (*model.Sale, error) {
	// Keep client and sponsor based on input client
	clientOID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, err
	}
	client, err := r.Resolver.clientService.GetByID(ctx, input.ClientID)
	if err != nil {
		return nil, err
	}
	sponsorOID := clientOID
	if client.SponsorID != nil {
		sponsorOID = *client.SponsorID
	}

	var productOID *primitive.ObjectID
	if input.ProductID != "" {
		poid, err := primitive.ObjectIDFromHex(input.ProductID)
		if err == nil {
			productOID = &poid
		}
	}
	status := "pending"
	if input.Status != nil {
		status = *input.Status
	}

	m := &models.Sale{
		ClientID:  clientOID,
		SponsorID: sponsorOID,
		ProductID: productOID,
		Amount:    input.Amount,
		Quantity:  int(input.Quantity),
		Status:    status,
		Note:      input.Note,
	}
	updated, err := r.Resolver.saleService.Update(ctx, id, m)
	if err != nil {
		return nil, err
	}
	var prodIdStr *string
	if updated.ProductID != nil {
		s := updated.ProductID.Hex()
		prodIdStr = &s
	}
	return &model.Sale{
		ID: updated.ID.Hex(), ClientID: updated.ClientID.Hex(), SponsorID: updated.SponsorID.Hex(), ProductID: prodIdStr,
		Amount: updated.Amount, Quantity: int32(updated.Quantity), Side: updated.Side, Date: updated.Date.Format(time.RFC3339), Status: updated.Status, Note: updated.Note,
	}, nil
}

// SaleDelete is the resolver for the saleDelete field.
func (r *mutationResolver) SaleDelete(ctx context.Context, id string) (bool, error) {
	return r.Resolver.saleService.Delete(ctx, id)
}

// PaymentCreate is the resolver for the paymentCreate field.
func (r *mutationResolver) PaymentCreate(ctx context.Context, input model.PaymentInput) (*model.Payment, error) {
	clientOID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, err
	}
	p := &models.Payment{
		ClientID:    clientOID,
		Amount:      input.Amount,
		Date:        time.Now(),
		Method:      input.Method,
		Status:      "completed",
		Description: input.Description,
	}
	created, err := r.Resolver.paymentService.Create(ctx, p)
	if err != nil {
		return nil, err
	}

	// Ajouter une sortie à la caisse pour ce paiement
	paymentRef := created.ID.Hex()
	refType := "payment"
	client, err := r.Resolver.clientService.GetByID(ctx, input.ClientID)
	clientName := "Client inconnu"
	if err == nil && client != nil {
		clientName = client.Name
	}
	desc := fmt.Sprintf("Paiement client - %s", clientName)
	if input.Description != nil {
		desc = *input.Description
	}
	caisseTransaction := &models.CaisseTransaction{
		Type:          "sortie",
		Amount:        created.Amount,
		Description:   &desc,
		Reference:     &paymentRef,
		ReferenceType: &refType,
	}
	_, err = r.Resolver.caisseService.AddTransaction(ctx, caisseTransaction)
	if err != nil {
		// Log error but don't fail the payment creation
		// In production, you might want to handle this differently
	}

	return &model.Payment{
		ID: created.ID.Hex(), ClientID: created.ClientID.Hex(), Amount: created.Amount,
		Date: created.Date.Format(time.RFC3339), Method: created.Method, Status: created.Status, Description: created.Description,
	}, nil
}

// PaymentUpdate is the resolver for the paymentUpdate field.
func (r *mutationResolver) PaymentUpdate(ctx context.Context, id string, input model.PaymentInput) (*model.Payment, error) {
	clientOID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, err
	}
	p := &models.Payment{
		ClientID:    clientOID,
		Amount:      input.Amount,
		Method:      input.Method,
		Description: input.Description,
	}
	updated, err := r.Resolver.paymentService.Update(ctx, id, p)
	if err != nil {
		return nil, err
	}
	return &model.Payment{
		ID: updated.ID.Hex(), ClientID: updated.ClientID.Hex(), Amount: updated.Amount,
		Date: updated.Date.Format(time.RFC3339), Method: updated.Method, Status: updated.Status, Description: updated.Description,
	}, nil
}

// PaymentDelete is the resolver for the paymentDelete field.
func (r *mutationResolver) PaymentDelete(ctx context.Context, id string) (bool, error) {
	return r.Resolver.paymentService.Delete(ctx, id)
}

// CommissionManualCreate is the resolver for the commissionManualCreate field.
func (r *mutationResolver) CommissionManualCreate(ctx context.Context, input model.CommissionInput) (*model.Commission, error) {
	clientOID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, err
	}
	sourceOID, err := primitive.ObjectIDFromHex(input.SourceClientID)
	if err != nil {
		return nil, err
	}
	c := &models.Commission{
		ClientID:       clientOID,
		SourceClientID: sourceOID,
		Amount:         input.Amount,
		Level:          int(input.Level),
		Type:           input.Type,
		Date:           time.Now(),
	}
	created, err := r.Resolver.commissionService.Create(ctx, c)
	if err != nil {
		return nil, err
	}
	return &model.Commission{
		ID: created.ID.Hex(), ClientID: created.ClientID.Hex(), SourceClientID: created.SourceClientID.Hex(), Amount: created.Amount,
		Level: int32(created.Level), Type: created.Type, Date: created.Date.Format(time.RFC3339),
	}, nil
}

// RunBinaryCommissionCheck is the resolver for the runBinaryCommissionCheck field.
func (r *mutationResolver) RunBinaryCommissionCheck(ctx context.Context, clientID string) (*model.CommissionResult, error) {
	res, err := r.Resolver.commissionService.RunBinaryCommissionCheck(ctx, clientID)
	if err != nil {
		return nil, err
	}
	return &model.CommissionResult{CommissionsCreated: int32(res.CommissionsCreated), TotalAmount: res.TotalAmount, Message: res.Message}, nil
}

// CaisseAddTransaction is the resolver for the caisseAddTransaction field.
func (r *mutationResolver) CaisseAddTransaction(ctx context.Context, input model.CaisseTransactionInput) (*model.CaisseTransaction, error) {
	transaction := &models.CaisseTransaction{
		Type:          input.Type,
		Amount:        input.Amount,
		Description:   input.Description,
		Reference:     input.Reference,
		ReferenceType: input.ReferenceType,
	}

	created, err := r.Resolver.caisseService.AddTransaction(ctx, transaction)
	if err != nil {
		return nil, err
	}

	return &model.CaisseTransaction{
		ID:            created.ID.Hex(),
		Type:          created.Type,
		Amount:        created.Amount,
		Description:   created.Description,
		Reference:     created.Reference,
		ReferenceType: created.ReferenceType,
		Date:          created.Date.Format(time.RFC3339),
		CreatedBy:     created.CreatedBy,
	}, nil
}

// CaisseUpdateBalance is the resolver for the caisseUpdateBalance field.
func (r *mutationResolver) CaisseUpdateBalance(ctx context.Context, balance float64) (*model.Caisse, error) {
	updated, err := r.Resolver.caisseService.UpdateBalance(ctx, balance)
	if err != nil {
		return nil, err
	}

	// Load transactions
	transactions, err := r.Resolver.caisseService.GetTransactions(ctx, nil, nil)
	if err != nil {
		transactions = []*models.CaisseTransaction{}
	}

	transactionsModel := make([]*model.CaisseTransaction, 0, len(transactions))
	for _, t := range transactions {
		transactionsModel = append(transactionsModel, &model.CaisseTransaction{
			ID:            t.ID.Hex(),
			Type:          t.Type,
			Amount:        t.Amount,
			Description:   t.Description,
			Reference:     t.Reference,
			ReferenceType: t.ReferenceType,
			Date:          t.Date.Format(time.RFC3339),
			CreatedBy:     t.CreatedBy,
		})
	}

	return &model.Caisse{
		ID:           updated.ID.Hex(),
		Balance:      updated.Balance,
		TotalEntrees: updated.TotalEntrees,
		TotalSorties: updated.TotalSorties,
		CreatedAt:    updated.CreatedAt.Format(time.RFC3339),
		UpdatedAt:    updated.UpdatedAt.Format(time.RFC3339),
		Transactions: transactionsModel,
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	// Try to read Authorization header from gqlgen operation context
	var token string
	if oc := graphql.GetOperationContext(ctx); oc != nil {
		if oc.Headers != nil {
			auth := oc.Headers.Get("Authorization")
			if strings.HasPrefix(strings.ToLower(auth), "bearer ") {
				token = strings.TrimSpace(auth[7:])
			}
		}
	}
	if token == "" {
		return nil, fmt.Errorf("unauthenticated")
	}
	admin, err := r.Resolver.authService.ValidateToken(ctx, token)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}
	return &model.User{
		ID:        admin.ID.Hex(),
		Name:      admin.Name,
		Email:     admin.Email,
		Role:      admin.Role,
		CreatedAt: admin.CreatedAt.Format(time.RFC3339),
	}, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.Product, error) {
	list, err := r.Resolver.productService.GetAll(ctx, nil, nil)
	if err != nil {
		return nil, err
	}
	out := make([]*model.Product, 0, len(list))
	for _, p := range list {
		out = append(out, &model.Product{
			ID: p.ID.Hex(), Name: p.Name, Description: p.Description, Price: p.Price, Stock: int32(p.Stock), Points: p.Points, ImageURL: p.ImageURL,
			CreatedAt: p.CreatedAt.Format(time.RFC3339), UpdatedAt: p.UpdatedAt.Format(time.RFC3339),
		})
	}
	return out, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id string) (*model.Product, error) {
	p, err := r.Resolver.productService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}
	return &model.Product{ID: p.ID.Hex(), Name: p.Name, Description: p.Description, Price: p.Price, Stock: int32(p.Stock), Points: p.Points, ImageURL: p.ImageURL, CreatedAt: p.CreatedAt.Format(time.RFC3339), UpdatedAt: p.UpdatedAt.Format(time.RFC3339)}, nil
}

// Clients is the resolver for the clients field.
func (r *queryResolver) Clients(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.Client, error) {
	// Minimal implementation: ignore filter/paging wiring for now
	clients, err := r.Resolver.clientService.GetAll(ctx, nil, nil)
	if err != nil {
		return nil, err
	}

	out := make([]*model.Client, 0, len(clients))
	for _, c := range clients {
		mc := &model.Client{
			ID:                 c.ID.Hex(),
			ClientID:           c.ClientID,
			Name:               c.Name,
			Phone:              c.Phone,
			Nn:                 c.NN,
			Address:            c.Address,
			Avatar:             c.Avatar,
			JoinDate:           c.JoinDate.Format(time.RFC3339),
			SponsorID:          nil,
			Position:           c.Position,
			LeftChildID:        nil,
			RightChildID:       nil,
			TotalEarnings:      c.TotalEarnings,
			WalletBalance:      c.WalletBalance,
			Points:             c.Points,
			NetworkVolumeLeft:  c.NetworkVolumeLeft,
			NetworkVolumeRight: c.NetworkVolumeRight,
			BinaryPairs:        int32(c.BinaryPairs),
		}
		if c.SponsorID != nil {
			sid := c.SponsorID.Hex()
			mc.SponsorID = &sid
			// hydrate sponsor
			sponsor, err := r.Resolver.clientService.GetByID(ctx, sid)
			if err == nil && sponsor != nil {
				mc.Sponsor = &model.Client{
					ID:          sponsor.ID.Hex(),
					ClientID:    sponsor.ClientID,
					Name:        sponsor.Name,
					Phone:       sponsor.Phone,
					Nn:          sponsor.NN,
					Address:     sponsor.Address,
					Avatar:      sponsor.Avatar,
					JoinDate:    sponsor.JoinDate.Format(time.RFC3339),
					Position:    sponsor.Position,
					BinaryPairs: int32(sponsor.BinaryPairs),
				}
			}
		}
		if c.LeftChildID != nil {
			lid := c.LeftChildID.Hex()
			mc.LeftChildID = &lid
			// hydrate left child
			leftChild, err := r.Resolver.clientService.GetByID(ctx, lid)
			if err == nil && leftChild != nil {
				mc.LeftChild = &model.Client{
					ID:          leftChild.ID.Hex(),
					ClientID:    leftChild.ClientID,
					Name:        leftChild.Name,
					Phone:       leftChild.Phone,
					Nn:          leftChild.NN,
					Address:     leftChild.Address,
					Avatar:      leftChild.Avatar,
					JoinDate:    leftChild.JoinDate.Format(time.RFC3339),
					Position:    leftChild.Position,
					BinaryPairs: int32(leftChild.BinaryPairs),
				}
			}
		}
		if c.RightChildID != nil {
			rid := c.RightChildID.Hex()
			mc.RightChildID = &rid
			// hydrate right child
			rightChild, err := r.Resolver.clientService.GetByID(ctx, rid)
			if err == nil && rightChild != nil {
				mc.RightChild = &model.Client{
					ID:          rightChild.ID.Hex(),
					ClientID:    rightChild.ClientID,
					Name:        rightChild.Name,
					Phone:       rightChild.Phone,
					Nn:          rightChild.NN,
					Address:     rightChild.Address,
					Avatar:      rightChild.Avatar,
					JoinDate:    rightChild.JoinDate.Format(time.RFC3339),
					Position:    rightChild.Position,
					BinaryPairs: int32(rightChild.BinaryPairs),
				}
			}
		}
		// Load transactions (payments)
		payments, err := r.Resolver.paymentService.GetByClientID(ctx, c.ID.Hex())
		if err == nil {
			mc.Transactions = make([]*model.Payment, 0, len(payments))
			for _, p := range payments {
				mc.Transactions = append(mc.Transactions, &model.Payment{
					ID:          p.ID.Hex(),
					ClientID:    p.ClientID.Hex(),
					Amount:      p.Amount,
					Date:        p.Date.Format(time.RFC3339),
					Method:      p.Method,
					Status:      p.Status,
					Description: p.Description,
				})
			}
		} else {
			mc.Transactions = []*model.Payment{}
		}

		// Load purchases (sales)
		sales, err := r.Resolver.saleService.GetByClientID(ctx, c.ID.Hex())
		if err == nil {
			mc.Purchases = make([]*model.Sale, 0, len(sales))
			for _, s := range sales {
				var prodIdStr *string
				if s.ProductID != nil {
					sid := s.ProductID.Hex()
					prodIdStr = &sid
				}
				mc.Purchases = append(mc.Purchases, &model.Sale{
					ID:        s.ID.Hex(),
					ClientID:  s.ClientID.Hex(),
					SponsorID: s.SponsorID.Hex(),
					ProductID: prodIdStr,
					Amount:    s.Amount,
					Quantity:  int32(s.Quantity),
					Side:      s.Side,
					Date:      s.Date.Format(time.RFC3339),
					Status:    s.Status,
					Note:      s.Note,
				})
			}
		} else {
			mc.Purchases = []*model.Sale{}
		}

		out = append(out, mc)
	}
	return out, nil
}

// Client is the resolver for the client field.
func (r *queryResolver) Client(ctx context.Context, id string) (*model.Client, error) {
	c, err := r.Resolver.clientService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}
	mc := &model.Client{
		ID:                 c.ID.Hex(),
		ClientID:           c.ClientID,
		Name:               c.Name,
		JoinDate:           c.JoinDate.Format(time.RFC3339),
		Position:           c.Position,
		TotalEarnings:      c.TotalEarnings,
		WalletBalance:      c.WalletBalance,
		Points:             c.Points,
		NetworkVolumeLeft:  c.NetworkVolumeLeft,
		NetworkVolumeRight: c.NetworkVolumeRight,
		BinaryPairs:        int32(c.BinaryPairs),
	}
	if c.SponsorID != nil {
		sid := c.SponsorID.Hex()
		mc.SponsorID = &sid
		sponsor, err := r.Resolver.clientService.GetByID(ctx, sid)
		if err == nil && sponsor != nil {
			mc.Sponsor = &model.Client{
				ID:          sponsor.ID.Hex(),
				ClientID:    sponsor.ClientID,
				Name:        sponsor.Name,
				Phone:       sponsor.Phone,
				Nn:          sponsor.NN,
				Address:     sponsor.Address,
				Avatar:      sponsor.Avatar,
				JoinDate:    sponsor.JoinDate.Format(time.RFC3339),
				Position:    sponsor.Position,
				BinaryPairs: int32(sponsor.BinaryPairs),
			}
		}
	}
	if c.LeftChildID != nil {
		lid := c.LeftChildID.Hex()
		mc.LeftChildID = &lid
		// hydrate left child
		leftChild, err := r.Resolver.clientService.GetByID(ctx, lid)
		if err == nil && leftChild != nil {
			mc.LeftChild = &model.Client{
				ID:          leftChild.ID.Hex(),
				ClientID:    leftChild.ClientID,
				Name:        leftChild.Name,
				Phone:       leftChild.Phone,
				Nn:          leftChild.NN,
				Address:     leftChild.Address,
				Avatar:      leftChild.Avatar,
				JoinDate:    leftChild.JoinDate.Format(time.RFC3339),
				Position:    leftChild.Position,
				BinaryPairs: int32(leftChild.BinaryPairs),
			}
		}
	}
	if c.RightChildID != nil {
		rid := c.RightChildID.Hex()
		mc.RightChildID = &rid
		// hydrate right child
		rightChild, err := r.Resolver.clientService.GetByID(ctx, rid)
		if err == nil && rightChild != nil {
			mc.RightChild = &model.Client{
				ID:          rightChild.ID.Hex(),
				ClientID:    rightChild.ClientID,
				Name:        rightChild.Name,
				Phone:       rightChild.Phone,
				Nn:          rightChild.NN,
				Address:     rightChild.Address,
				Avatar:      rightChild.Avatar,
				JoinDate:    rightChild.JoinDate.Format(time.RFC3339),
				Position:    rightChild.Position,
				BinaryPairs: int32(rightChild.BinaryPairs),
			}
		}
	}

	// Load transactions (payments)
	payments, err := r.Resolver.paymentService.GetByClientID(ctx, c.ID.Hex())
	if err == nil {
		mc.Transactions = make([]*model.Payment, 0, len(payments))
		for _, p := range payments {
			mc.Transactions = append(mc.Transactions, &model.Payment{
				ID:          p.ID.Hex(),
				ClientID:    p.ClientID.Hex(),
				Amount:      p.Amount,
				Date:        p.Date.Format(time.RFC3339),
				Method:      p.Method,
				Status:      p.Status,
				Description: p.Description,
			})
		}
	} else {
		mc.Transactions = []*model.Payment{}
	}

	// Load purchases (sales)
	sales, err := r.Resolver.saleService.GetByClientID(ctx, c.ID.Hex())
	if err == nil {
		mc.Purchases = make([]*model.Sale, 0, len(sales))
		for _, s := range sales {
			var prodIdStr *string
			if s.ProductID != nil {
				sid := s.ProductID.Hex()
				prodIdStr = &sid
			}
			mc.Purchases = append(mc.Purchases, &model.Sale{
				ID:        s.ID.Hex(),
				ClientID:  s.ClientID.Hex(),
				SponsorID: s.SponsorID.Hex(),
				ProductID: prodIdStr,
				Amount:    s.Amount,
				Quantity:  int32(s.Quantity),
				Side:      s.Side,
				Date:      s.Date.Format(time.RFC3339),
				Status:    s.Status,
				Note:      s.Note,
			})
		}
	} else {
		mc.Purchases = []*model.Sale{}
	}

	return mc, nil
}

// Sales is the resolver for the sales field.
func (r *queryResolver) Sales(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.Sale, error) {
	// Convert GraphQL model to internal model
	var filterModel *models.FilterInput
	if filter != nil {
		filterModel = &models.FilterInput{
			Search:   filter.Search,
			DateFrom: nil, // Convert if needed
			DateTo:   nil, // Convert if needed
			Status:   filter.Status,
		}
	}

	var pagingModel *models.PagingInput
	if paging != nil {
		var page *int
		var limit *int
		if paging.Page != nil {
			p := int(*paging.Page)
			page = &p
		}
		if paging.Limit != nil {
			l := int(*paging.Limit)
			limit = &l
		}
		pagingModel = &models.PagingInput{
			Page:  page,
			Limit: limit,
		}
	}

	sales, err := r.Resolver.saleService.GetAll(ctx, filterModel, pagingModel)
	if err != nil {
		return nil, err
	}

	out := make([]*model.Sale, 0, len(sales))
	for _, s := range sales {
		var prodIdStr *string
		if s.ProductID != nil {
			sid := s.ProductID.Hex()
			prodIdStr = &sid
		}

		sale := &model.Sale{
			ID:        s.ID.Hex(),
			ClientID:  s.ClientID.Hex(),
			SponsorID: s.SponsorID.Hex(),
			ProductID: prodIdStr,
			Amount:    s.Amount,
			Quantity:  int32(s.Quantity),
			Side:      s.Side,
			Date:      s.Date.Format(time.RFC3339),
			Status:    s.Status,
			Note:      s.Note,
		}

		// Hydrate client
		client, err := r.Resolver.clientService.GetByID(ctx, s.ClientID.Hex())
		if err == nil && client != nil {
			sale.Client = &model.Client{
				ID:                 client.ID.Hex(),
				ClientID:           client.ClientID,
				Name:               client.Name,
				Phone:              client.Phone,
				Nn:                 client.NN,
				Address:            client.Address,
				Avatar:             client.Avatar,
				SponsorID:          nil,
				Position:           client.Position,
				LeftChildID:        nil,
				RightChildID:       nil,
				JoinDate:           client.JoinDate.Format(time.RFC3339),
				TotalEarnings:      client.TotalEarnings,
				WalletBalance:      client.WalletBalance,
				Points:             client.Points,
				NetworkVolumeLeft:  client.NetworkVolumeLeft,
				NetworkVolumeRight: client.NetworkVolumeRight,
				BinaryPairs:        int32(client.BinaryPairs),
			}
			if client.SponsorID != nil {
				sid := client.SponsorID.Hex()
				sale.Client.SponsorID = &sid
			}
			if client.LeftChildID != nil {
				lid := client.LeftChildID.Hex()
				sale.Client.LeftChildID = &lid
			}
			if client.RightChildID != nil {
				rid := client.RightChildID.Hex()
				sale.Client.RightChildID = &rid
			}
		}

		// Hydrate sponsor
		sponsor, err := r.Resolver.clientService.GetByID(ctx, s.SponsorID.Hex())
		if err == nil && sponsor != nil {
			sale.Sponsor = &model.Client{
				ID:                 sponsor.ID.Hex(),
				ClientID:           sponsor.ClientID,
				Name:               sponsor.Name,
				Phone:              sponsor.Phone,
				Nn:                 sponsor.NN,
				Address:            sponsor.Address,
				Avatar:             sponsor.Avatar,
				SponsorID:          nil,
				Position:           sponsor.Position,
				LeftChildID:        nil,
				RightChildID:       nil,
				JoinDate:           sponsor.JoinDate.Format(time.RFC3339),
				TotalEarnings:      sponsor.TotalEarnings,
				WalletBalance:      sponsor.WalletBalance,
				Points:             sponsor.Points,
				NetworkVolumeLeft:  sponsor.NetworkVolumeLeft,
				NetworkVolumeRight: sponsor.NetworkVolumeRight,
				BinaryPairs:        int32(sponsor.BinaryPairs),
			}
			if sponsor.SponsorID != nil {
				sid := sponsor.SponsorID.Hex()
				sale.Sponsor.SponsorID = &sid
			}
			if sponsor.LeftChildID != nil {
				lid := sponsor.LeftChildID.Hex()
				sale.Sponsor.LeftChildID = &lid
			}
			if sponsor.RightChildID != nil {
				rid := sponsor.RightChildID.Hex()
				sale.Sponsor.RightChildID = &rid
			}
		}

		// Hydrate product
		if s.ProductID != nil {
			product, err := r.Resolver.productService.GetByID(ctx, s.ProductID.Hex())
			if err == nil && product != nil {
				sale.Product = &model.Product{
					ID:          product.ID.Hex(),
					Name:        product.Name,
					Description: product.Description,
					Price:       product.Price,
					Stock:       int32(product.Stock),
					Points:      product.Points,
					ImageURL:    product.ImageURL,
					CreatedAt:   product.CreatedAt.Format(time.RFC3339),
					UpdatedAt:   product.UpdatedAt.Format(time.RFC3339),
				}
			}
		}

		out = append(out, sale)
	}
	return out, nil
}

// Sale is the resolver for the sale field.
func (r *queryResolver) Sale(ctx context.Context, id string) (*model.Sale, error) {
	s, err := r.Resolver.saleService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	var prodIdStr *string
	if s.ProductID != nil {
		sid := s.ProductID.Hex()
		prodIdStr = &sid
	}

	sale := &model.Sale{
		ID:        s.ID.Hex(),
		ClientID:  s.ClientID.Hex(),
		SponsorID: s.SponsorID.Hex(),
		ProductID: prodIdStr,
		Amount:    s.Amount,
		Quantity:  int32(s.Quantity),
		Side:      s.Side,
		Date:      s.Date.Format(time.RFC3339),
		Status:    s.Status,
		Note:      s.Note,
	}

	// Hydrate client
	client, err := r.Resolver.clientService.GetByID(ctx, s.ClientID.Hex())
	if err == nil && client != nil {
		sale.Client = &model.Client{
			ID:                 client.ID.Hex(),
			ClientID:           client.ClientID,
			Name:               client.Name,
			Phone:              client.Phone,
			Nn:                 client.NN,
			Address:            client.Address,
			Avatar:             client.Avatar,
			SponsorID:          nil,
			Position:           client.Position,
			LeftChildID:        nil,
			RightChildID:       nil,
			JoinDate:           client.JoinDate.Format(time.RFC3339),
			TotalEarnings:      client.TotalEarnings,
			WalletBalance:      client.WalletBalance,
			Points:             client.Points,
			NetworkVolumeLeft:  client.NetworkVolumeLeft,
			NetworkVolumeRight: client.NetworkVolumeRight,
			BinaryPairs:        int32(client.BinaryPairs),
		}
		if client.SponsorID != nil {
			sid := client.SponsorID.Hex()
			sale.Client.SponsorID = &sid
		}
		if client.LeftChildID != nil {
			lid := client.LeftChildID.Hex()
			sale.Client.LeftChildID = &lid
		}
		if client.RightChildID != nil {
			rid := client.RightChildID.Hex()
			sale.Client.RightChildID = &rid
		}
	}

	// Hydrate sponsor
	sponsor, err := r.Resolver.clientService.GetByID(ctx, s.SponsorID.Hex())
	if err == nil && sponsor != nil {
		sale.Sponsor = &model.Client{
			ID:                 sponsor.ID.Hex(),
			ClientID:           sponsor.ClientID,
			Name:               sponsor.Name,
			SponsorID:          nil,
			Position:           sponsor.Position,
			LeftChildID:        nil,
			RightChildID:       nil,
			JoinDate:           sponsor.JoinDate.Format(time.RFC3339),
			TotalEarnings:      sponsor.TotalEarnings,
			WalletBalance:      sponsor.WalletBalance,
			Points:             sponsor.Points,
			NetworkVolumeLeft:  sponsor.NetworkVolumeLeft,
			NetworkVolumeRight: sponsor.NetworkVolumeRight,
			BinaryPairs:        int32(sponsor.BinaryPairs),
		}
		if sponsor.SponsorID != nil {
			sid := sponsor.SponsorID.Hex()
			sale.Sponsor.SponsorID = &sid
		}
		if sponsor.LeftChildID != nil {
			lid := sponsor.LeftChildID.Hex()
			sale.Sponsor.LeftChildID = &lid
		}
		if sponsor.RightChildID != nil {
			rid := sponsor.RightChildID.Hex()
			sale.Sponsor.RightChildID = &rid
		}
	}

	// Hydrate product
	if s.ProductID != nil {
		product, err := r.Resolver.productService.GetByID(ctx, s.ProductID.Hex())
		if err == nil && product != nil {
			sale.Product = &model.Product{
				ID:          product.ID.Hex(),
				Name:        product.Name,
				Description: product.Description,
				Price:       product.Price,
				Stock:       int32(product.Stock),
				Points:      product.Points,
				ImageURL:    product.ImageURL,
				CreatedAt:   product.CreatedAt.Format(time.RFC3339),
				UpdatedAt:   product.UpdatedAt.Format(time.RFC3339),
			}
		}
	}

	return sale, nil
}

// Payments is the resolver for the payments field.
func (r *queryResolver) Payments(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.Payment, error) {
	list, err := r.Resolver.paymentService.GetAll(ctx, nil, nil)
	if err != nil {
		return nil, err
	}
	out := make([]*model.Payment, 0, len(list))
	for _, p := range list {
		out = append(out, &model.Payment{ID: p.ID.Hex(), ClientID: p.ClientID.Hex(), Amount: p.Amount, Date: p.Date.Format(time.RFC3339), Method: p.Method, Status: p.Status, Description: p.Description})
	}
	return out, nil
}

// Payment is the resolver for the payment field.
func (r *queryResolver) Payment(ctx context.Context, id string) (*model.Payment, error) {
	p, err := r.Resolver.paymentService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}
	return &model.Payment{ID: p.ID.Hex(), ClientID: p.ClientID.Hex(), Amount: p.Amount, Date: p.Date.Format(time.RFC3339), Method: p.Method, Status: p.Status, Description: p.Description}, nil
}

// Commissions is the resolver for the commissions field.
func (r *queryResolver) Commissions(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.Commission, error) {
	list, err := r.Resolver.commissionService.GetAll(ctx, nil, nil)
	if err != nil {
		return nil, err
	}
	out := make([]*model.Commission, 0, len(list))
	for _, c := range list {
		out = append(out, &model.Commission{ID: c.ID.Hex(), ClientID: c.ClientID.Hex(), SourceClientID: c.SourceClientID.Hex(), Amount: c.Amount, Level: int32(c.Level), Type: c.Type, Date: c.Date.Format(time.RFC3339)})
	}
	return out, nil
}

// Commission is the resolver for the commission field.
func (r *queryResolver) Commission(ctx context.Context, id string) (*model.Commission, error) {
	c, err := r.Resolver.commissionService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}
	return &model.Commission{ID: c.ID.Hex(), ClientID: c.ClientID.Hex(), SourceClientID: c.SourceClientID.Hex(), Amount: c.Amount, Level: int32(c.Level), Type: c.Type, Date: c.Date.Format(time.RFC3339)}, nil
}

// DashboardStats is the resolver for the dashboardStats field.
func (r *queryResolver) DashboardStats(ctx context.Context, rangeArg *string) (*model.DashboardStats, error) {
	s, err := r.Resolver.adminService.GetDashboardStats(ctx, rangeArg)
	if err != nil {
		return nil, err
	}
	return &model.DashboardStats{
		TotalProducts: int32(s.TotalProducts), TotalClients: int32(s.TotalClients), TotalSales: s.TotalSales, TotalCommissions: s.TotalCommissions,
		TotalRevenue: 0, ActiveClients: int32(s.ActiveClients), LeftVolume: 0, RightVolume: 0, BinaryPairs: 0, NetworkBalance: 0,
		MonthlySales: []*model.MonthlySales{}, NetworkGrowth: []*model.NetworkGrowth{}, SalesStatus: &model.SalesStatus{}, TopProducts: []*model.TopProduct{}, RecentActivity: []*model.RecentActivity{},
	}, nil
}

// DashboardData is the resolver for the dashboardData field.
func (r *queryResolver) DashboardData(ctx context.Context) (*model.DashboardStats, error) {
	s, err := r.Resolver.adminService.GetDashboardStats(ctx, nil)
	if err != nil {
		return nil, err
	}
	return &model.DashboardStats{
		TotalProducts: int32(s.TotalProducts), TotalClients: int32(s.TotalClients), TotalSales: s.TotalSales, TotalCommissions: s.TotalCommissions,
		TotalRevenue: 0, ActiveClients: int32(s.ActiveClients), LeftVolume: 0, RightVolume: 0, BinaryPairs: 0, NetworkBalance: 0,
		MonthlySales: []*model.MonthlySales{}, NetworkGrowth: []*model.NetworkGrowth{}, SalesStatus: &model.SalesStatus{}, TopProducts: []*model.TopProduct{}, RecentActivity: []*model.RecentActivity{},
	}, nil
}

// Caisse is the resolver for the caisse field.
func (r *queryResolver) Caisse(ctx context.Context) (*model.Caisse, error) {
	caisse, err := r.Resolver.caisseService.GetCaisse(ctx)
	if err != nil {
		return nil, err
	}

	// Load transactions
	transactions, err := r.Resolver.caisseService.GetTransactions(ctx, nil, nil)
	if err != nil {
		transactions = []*models.CaisseTransaction{}
	}

	transactionsModel := make([]*model.CaisseTransaction, 0, len(transactions))
	for _, t := range transactions {
		transactionsModel = append(transactionsModel, &model.CaisseTransaction{
			ID:            t.ID.Hex(),
			Type:          t.Type,
			Amount:        t.Amount,
			Description:   t.Description,
			Reference:     t.Reference,
			ReferenceType: t.ReferenceType,
			Date:          t.Date.Format(time.RFC3339),
			CreatedBy:     t.CreatedBy,
		})
	}

	return &model.Caisse{
		ID:           caisse.ID.Hex(),
		Balance:      caisse.Balance,
		TotalEntrees: caisse.TotalEntrees,
		TotalSorties: caisse.TotalSorties,
		CreatedAt:    caisse.CreatedAt.Format(time.RFC3339),
		UpdatedAt:    caisse.UpdatedAt.Format(time.RFC3339),
		Transactions: transactionsModel,
	}, nil
}

// CaisseTransactions is the resolver for the caisseTransactions field.
func (r *queryResolver) CaisseTransactions(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.CaisseTransaction, error) {
	// Convert GraphQL model to internal model
	var filterModel *models.FilterInput
	if filter != nil {
		filterModel = &models.FilterInput{
			Search:   filter.Search,
			DateFrom: nil, // Convert if needed
			DateTo:   nil, // Convert if needed
			Status:   filter.Status,
		}
	}

	var pagingModel *models.PagingInput
	if paging != nil {
		var page *int
		var limit *int
		if paging.Page != nil {
			p := int(*paging.Page)
			page = &p
		}
		if paging.Limit != nil {
			l := int(*paging.Limit)
			limit = &l
		}
		pagingModel = &models.PagingInput{
			Page:  page,
			Limit: limit,
		}
	}

	transactions, err := r.Resolver.caisseService.GetTransactions(ctx, filterModel, pagingModel)
	if err != nil {
		return nil, err
	}

	out := make([]*model.CaisseTransaction, 0, len(transactions))
	for _, t := range transactions {
		out = append(out, &model.CaisseTransaction{
			ID:            t.ID.Hex(),
			Type:          t.Type,
			Amount:        t.Amount,
			Description:   t.Description,
			Reference:     t.Reference,
			ReferenceType: t.ReferenceType,
			Date:          t.Date.Format(time.RFC3339),
			CreatedBy:     t.CreatedBy,
		})
	}
	return out, nil
}

// OnNewSale is the resolver for the onNewSale field.
func (r *subscriptionResolver) OnNewSale(ctx context.Context) (<-chan *model.Sale, error) {
	ch := make(chan *model.Sale, 1)
	return ch, nil
}

// OnNewCommission is the resolver for the onNewCommission field.
func (r *subscriptionResolver) OnNewCommission(ctx context.Context) (<-chan *model.Commission, error) {
	ch := make(chan *model.Commission, 1)
	return ch, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
