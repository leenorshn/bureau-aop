package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"bureau/graph/model"
	"bureau/internal/auth"
	"bureau/internal/models"
	"bureau/internal/validation"
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// UserLogin is the resolver for the userLogin field.
func (r *mutationResolver) UserLogin(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	// Validate input
	if err := validation.ValidateEmail(input.Email); err != nil {
		return nil, err
	}

	ap, err := r.Resolver.authService.AdminLogin(ctx, input.Email, input.Password)
	if err != nil {
		return nil, err
	}
	user := &model.User{
		ID:    ap.Admin.ID.Hex(),
		Name:  ap.Admin.Name,
		Email: ap.Admin.Email,
		Role:  ap.Admin.Role,
		// CreatedAt omitted for brevity
	}
	return &model.AuthPayload{AccessToken: ap.AccessToken, RefreshToken: ap.RefreshToken, User: user}, nil
}

// ClientLogin is the resolver for the clientLogin field.
func (r *mutationResolver) ClientLogin(ctx context.Context, input model.ClientLoginInput) (*model.AuthPayload, error) {
	// Authenticate client by clientId/password
	c, err := r.Resolver.clientService.AuthenticateClient(ctx, input.ClientID, input.Password)
	if err != nil {
		return nil, err
	}
	// Generate client JWT tokens
	jwt := r.Resolver.authService.GetJWTService()
	access, err := jwt.GenerateClientAccessToken(c)
	if err != nil {
		return nil, err
	}
	refresh, err := jwt.GenerateClientRefreshToken(c)
	if err != nil {
		return nil, err
	}
	return &model.AuthPayload{
		AccessToken:  access,
		RefreshToken: refresh,
		User: &model.User{
			ID:        c.ID.Hex(),
			Name:      c.Name,
			Email:     "",
			Role:      "client",
			CreatedAt: "",
		},
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, input model.RefreshTokenInput) (*model.AuthPayload, error) {
	ap, err := r.Resolver.authService.RefreshToken(ctx, input.Token)
	if err != nil {
		return nil, err
	}
	user := &model.User{
		ID:    ap.Admin.ID.Hex(),
		Name:  ap.Admin.Name,
		Email: ap.Admin.Email,
		Role:  ap.Admin.Role,
	}
	return &model.AuthPayload{AccessToken: ap.AccessToken, RefreshToken: ap.RefreshToken, User: user}, nil
}

// ChangePassword is the resolver for the changePassword field.
// Permet à un utilisateur authentifié (admin ou client) de changer son propre mot de passe
func (r *mutationResolver) ChangePassword(ctx context.Context, input model.ChangePasswordInput) (bool, error) {
	// Obtenir le token depuis les headers
	var token string
	if oc := graphql.GetOperationContext(ctx); oc != nil {
		if oc.Headers != nil {
			auth := oc.Headers.Get("Authorization")
			if strings.HasPrefix(strings.ToLower(auth), "bearer ") {
				token = strings.TrimSpace(auth[7:])
			}
		}
	}
	if token == "" {
		return false, errors.New("authentification requise")
	}

	// Valider le nouveau mot de passe
	if err := auth.ValidatePassword(input.NewPassword); err != nil {
		return false, err
	}

	// Essayer d'abord comme admin
	admin, err := r.Resolver.authService.ValidateToken(ctx, token)
	if err == nil && admin != nil {
		// Vérifier le mot de passe actuel
		if !auth.CheckPasswordHash(input.CurrentPassword, admin.PasswordHash) {
			return false, errors.New("mot de passe actuel incorrect")
		}

		// Mettre à jour le mot de passe de l'admin
		err = r.Resolver.authService.UpdateAdminPassword(ctx, admin.ID.Hex(), input.NewPassword)
		if err != nil {
			return false, err
		}
		return true, nil
	}

	// Si ce n'est pas un admin, essayer comme client
	jwt := r.Resolver.authService.GetJWTService()
	claims, err := jwt.ValidateAccessToken(token)
	if err == nil && claims != nil && claims.ClientID != "" {
		// Récupérer le client
		client, err := r.Resolver.clientService.GetByID(ctx, claims.ClientID)
		if err != nil {
			return false, errors.New("client introuvable")
		}

		// Vérifier le mot de passe actuel
		if !auth.CheckPasswordHash(input.CurrentPassword, client.PasswordHash) {
			return false, errors.New("mot de passe actuel incorrect")
		}

		// Mettre à jour le mot de passe du client
		err = r.Resolver.clientService.UpdatePassword(ctx, client.ID.Hex(), input.NewPassword)
		if err != nil {
			return false, err
		}
		return true, nil
	}

	return false, errors.New("authentification invalide")
}

// ResetAdminPassword is the resolver for the resetAdminPassword field.
// Permet à un admin de réinitialiser le mot de passe d'un autre admin (nécessite authentification admin)
func (r *mutationResolver) ResetAdminPassword(ctx context.Context, input model.ResetPasswordInput) (bool, error) {
	// Vérifier que l'utilisateur est authentifié comme admin
	var token string
	if oc := graphql.GetOperationContext(ctx); oc != nil {
		if oc.Headers != nil {
			auth := oc.Headers.Get("Authorization")
			if strings.HasPrefix(strings.ToLower(auth), "bearer ") {
				token = strings.TrimSpace(auth[7:])
			}
		}
	}
	if token == "" {
		return false, errors.New("authentification admin requise")
	}

	_, err := r.Resolver.authService.ValidateToken(ctx, token)
	if err != nil {
		return false, errors.New("authentification admin requise")
	}

	// Valider l'ID
	if err := validation.ValidateObjectID(input.ID); err != nil {
		return false, err
	}

	// Valider le nouveau mot de passe
	if err := auth.ValidatePassword(input.NewPassword); err != nil {
		return false, err
	}

	// Mettre à jour le mot de passe
	err = r.Resolver.authService.UpdateAdminPassword(ctx, input.ID, input.NewPassword)
	if err != nil {
		return false, fmt.Errorf("erreur lors de la réinitialisation: %w", err)
	}

	return true, nil
}

// ResetAdminPasswordByEmail is the resolver for the resetAdminPasswordByEmail field.
// Permet à un admin de réinitialiser le mot de passe d'un autre admin par email
func (r *mutationResolver) ResetAdminPasswordByEmail(ctx context.Context, input model.ResetPasswordByEmailInput) (bool, error) {
	// Vérifier que l'utilisateur est authentifié comme admin
	var token string
	if oc := graphql.GetOperationContext(ctx); oc != nil {
		if oc.Headers != nil {
			auth := oc.Headers.Get("Authorization")
			if strings.HasPrefix(strings.ToLower(auth), "bearer ") {
				token = strings.TrimSpace(auth[7:])
			}
		}
	}
	if token == "" {
		return false, errors.New("authentification admin requise")
	}

	_, err := r.Resolver.authService.ValidateToken(ctx, token)
	if err != nil {
		return false, errors.New("authentification admin requise")
	}

	// Valider l'email
	if err := validation.ValidateEmail(input.Email); err != nil {
		return false, err
	}

	// Mettre à jour le mot de passe
	err = r.Resolver.authService.UpdateAdminPasswordByEmail(ctx, input.Email, input.NewPassword)
	if err != nil {
		return false, fmt.Errorf("erreur lors de la réinitialisation: %w", err)
	}

	return true, nil
}

// ResetClientPassword is the resolver for the resetClientPassword field.
// Permet à un admin de réinitialiser le mot de passe d'un client
func (r *mutationResolver) ResetClientPassword(ctx context.Context, input model.ResetClientPasswordInput) (bool, error) {
	// Vérifier que l'utilisateur est authentifié comme admin
	var token string
	if oc := graphql.GetOperationContext(ctx); oc != nil {
		if oc.Headers != nil {
			auth := oc.Headers.Get("Authorization")
			if strings.HasPrefix(strings.ToLower(auth), "bearer ") {
				token = strings.TrimSpace(auth[7:])
			}
		}
	}
	if token == "" {
		return false, errors.New("authentification admin requise")
	}

	_, err := r.Resolver.authService.ValidateToken(ctx, token)
	if err != nil {
		return false, errors.New("authentification admin requise")
	}

	// Valider le nouveau mot de passe
	if err := auth.ValidatePassword(input.NewPassword); err != nil {
		return false, err
	}

	// Mettre à jour le mot de passe
	err = r.Resolver.clientService.UpdatePasswordByClientID(ctx, input.ClientID, input.NewPassword)
	if err != nil {
		return false, fmt.Errorf("erreur lors de la réinitialisation: %w", err)
	}

	return true, nil
}

// ProductCreate is the resolver for the productCreate field.
func (r *mutationResolver) ProductCreate(ctx context.Context, input model.ProductInput) (*model.Product, error) {
	// Validate input
	if err := validation.ValidateName(input.Name); err != nil {
		return nil, err
	}
	if err := validation.ValidatePrice(input.Price); err != nil {
		return nil, err
	}
	if err := validation.ValidateStock(input.Stock); err != nil {
		return nil, err
	}
	if err := validation.ValidateAmount(input.Points); err != nil {
		return nil, err
	}

	now := time.Now()
	p := &models.Product{
		Name:        input.Name,
		Description: input.Description,
		Price:       input.Price,
		Stock:       int(input.Stock),
		Points:      input.Points,
		ImageURL:    input.ImageURL,
		CreatedAt:   now,
		UpdatedAt:   now,
	}
	created, err := r.Resolver.productService.Create(ctx, p)
	if err != nil {
		return nil, err
	}
	return &model.Product{
		ID:          created.ID.Hex(),
		Name:        created.Name,
		Description: created.Description,
		Price:       created.Price,
		Stock:       int32(created.Stock),
		Points:      created.Points,
		ImageURL:    created.ImageURL,
		CreatedAt:   created.CreatedAt.Format(time.RFC3339),
		UpdatedAt:   created.UpdatedAt.Format(time.RFC3339),
	}, nil
}

// ProductUpdate is the resolver for the productUpdate field.
func (r *mutationResolver) ProductUpdate(ctx context.Context, id string, input model.ProductInput) (*model.Product, error) {
	// Validate ID
	if err := validation.ValidateObjectID(id); err != nil {
		return nil, err
	}

	// Validate input
	if err := validation.ValidateName(input.Name); err != nil {
		return nil, err
	}
	if err := validation.ValidatePrice(input.Price); err != nil {
		return nil, err
	}
	if err := validation.ValidateStock(input.Stock); err != nil {
		return nil, err
	}
	if err := validation.ValidateAmount(input.Points); err != nil {
		return nil, err
	}

	now := time.Now()
	p := &models.Product{
		Name:        input.Name,
		Description: input.Description,
		Price:       input.Price,
		Stock:       int(input.Stock),
		Points:      input.Points,
		ImageURL:    input.ImageURL,
		UpdatedAt:   now,
	}
	updated, err := r.Resolver.productService.Update(ctx, id, p)
	if err != nil {
		return nil, err
	}
	return &model.Product{
		ID:          updated.ID.Hex(),
		Name:        updated.Name,
		Description: updated.Description,
		Price:       updated.Price,
		Stock:       int32(updated.Stock),
		Points:      updated.Points,
		ImageURL:    updated.ImageURL,
		CreatedAt:   updated.CreatedAt.Format(time.RFC3339),
		UpdatedAt:   updated.UpdatedAt.Format(time.RFC3339),
	}, nil
}

// ProductDelete is the resolver for the productDelete field.
func (r *mutationResolver) ProductDelete(ctx context.Context, id string) (bool, error) {
	if err := validation.ValidateObjectID(id); err != nil {
		return false, err
	}
	return r.Resolver.productService.Delete(ctx, id)
}

// ClientCreate is the resolver for the clientCreate field.
func (r *mutationResolver) ClientCreate(ctx context.Context, input model.ClientInput) (*model.Client, error) {
	// Validate input
	if err := validation.ValidateName(input.Name); err != nil {
		return nil, err
	}
	if err := auth.ValidatePassword(input.Password); err != nil {
		return nil, err
	}
	if err := validation.ValidateObjectIDPtr(input.SponsorID); err != nil {
		return nil, err
	}
	if err := validation.ValidatePositionPtr(input.Position); err != nil {
		return nil, err
	}

	var sponsorOID *primitive.ObjectID
	if input.SponsorID != nil {
		oid, err := primitive.ObjectIDFromHex(*input.SponsorID)
		if err == nil {
			sponsorOID = &oid
		}
	}

	var requestedPosition *string
	if input.Position != nil && *input.Position != "" {
		requestedPosition = input.Position
	}

	now := time.Now()
	m := &models.Client{
		Name:         input.Name,
		PasswordHash: input.Password, // service will hash
		Phone:        input.Phone,
		NN:           input.Nn,
		Address:      input.Address,
		Avatar:       input.Avatar,
		JoinDate:     now,
	}
	created, err := r.Resolver.clientService.CreateWithBinaryPlacement(ctx, m, sponsorOID, requestedPosition)
	if err != nil {
		return nil, err
	}
	out := &model.Client{
		ID:                 created.ID.Hex(),
		ClientID:           created.ClientID,
		Name:               created.Name,
		Phone:              created.Phone,
		Nn:                 created.NN,
		Address:            created.Address,
		Avatar:             created.Avatar,
		JoinDate:           created.JoinDate.Format(time.RFC3339),
		Position:           created.Position,
		TotalEarnings:      created.TotalEarnings,
		WalletBalance:      created.WalletBalance,
		Points:             created.Points,
		NetworkVolumeLeft:  created.NetworkVolumeLeft,
		NetworkVolumeRight: created.NetworkVolumeRight,
		BinaryPairs:        int32(created.BinaryPairs),
	}
	if created.SponsorID != nil {
		sid := created.SponsorID.Hex()
		out.SponsorID = &sid
	}
	if created.LeftChildID != nil {
		lid := created.LeftChildID.Hex()
		out.LeftChildID = &lid
	}
	if created.RightChildID != nil {
		rid := created.RightChildID.Hex()
		out.RightChildID = &rid
	}
	return out, nil
}

// ClientUpdate is the resolver for the clientUpdate field.
func (r *mutationResolver) ClientUpdate(ctx context.Context, id string, input model.ClientInput) (*model.Client, error) {
	m := &models.Client{
		Name:    input.Name,
		Phone:   input.Phone,
		NN:      input.Nn,
		Address: input.Address,
		Avatar:  input.Avatar,
	}
	updated, err := r.Resolver.clientService.Update(ctx, id, m)
	if err != nil {
		return nil, err
	}
	out := &model.Client{
		ID:                 updated.ID.Hex(),
		ClientID:           updated.ClientID,
		Name:               updated.Name,
		Phone:              updated.Phone,
		Nn:                 updated.NN,
		Address:            updated.Address,
		Avatar:             updated.Avatar,
		JoinDate:           updated.JoinDate.Format(time.RFC3339),
		Position:           updated.Position,
		TotalEarnings:      updated.TotalEarnings,
		WalletBalance:      updated.WalletBalance,
		Points:             updated.Points,
		NetworkVolumeLeft:  updated.NetworkVolumeLeft,
		NetworkVolumeRight: updated.NetworkVolumeRight,
		BinaryPairs:        int32(updated.BinaryPairs),
	}
	if updated.SponsorID != nil {
		sid := updated.SponsorID.Hex()
		out.SponsorID = &sid
	}
	if updated.LeftChildID != nil {
		lid := updated.LeftChildID.Hex()
		out.LeftChildID = &lid
	}
	if updated.RightChildID != nil {
		rid := updated.RightChildID.Hex()
		out.RightChildID = &rid
	}
	return out, nil
}

// ClientDelete is the resolver for the clientDelete field.
func (r *mutationResolver) ClientDelete(ctx context.Context, id string) (bool, error) {
	if err := validation.ValidateObjectID(id); err != nil {
		return false, err
	}
	return r.Resolver.clientService.Delete(ctx, id)
}

// SaleCreate is the resolver for the saleCreate field.
func (r *mutationResolver) SaleCreate(ctx context.Context, input model.SaleInput) (*model.Sale, error) {
	// Validate input
	if err := validation.ValidateObjectID(input.ClientID); err != nil {
		return nil, err
	}
	if err := validation.ValidateObjectIDPtr(input.ProductID); err != nil {
		return nil, err
	}
	if err := validation.ValidateQuantity(input.Quantity); err != nil {
		return nil, err
	}
	if err := validation.ValidateAmountPositive(input.Amount); err != nil {
		return nil, err
	}
	if err := validation.ValidateAmountPtr(input.PaidAmount); err != nil {
		return nil, err
	}
	if input.Status != nil {
		if err := validation.ValidateSaleStatus(*input.Status); err != nil {
			return nil, err
		}
	}

	// Resolve client
	clientOID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, err
	}
	client, err := r.Resolver.clientService.GetByID(ctx, input.ClientID)
	if err != nil {
		return nil, err
	}

	// Resolve product and get points
	var productOID *primitive.ObjectID
	var pointsToAdd float64
	if input.ProductID != nil && *input.ProductID != "" {
		poid, err := primitive.ObjectIDFromHex(*input.ProductID)
		if err == nil {
			productOID = &poid
			// Get product to retrieve points and check stock
			product, err := r.Resolver.productService.GetByID(ctx, *input.ProductID)
			if err != nil {
				return nil, fmt.Errorf("produit introuvable: %w", err)
			}
			if product == nil {
				return nil, errors.New("produit introuvable")
			}

			// Vérifier que le stock est suffisant
			if product.Stock < int(input.Quantity) {
				return nil, fmt.Errorf("stock insuffisant: disponible %d, demandé %d", product.Stock, input.Quantity)
			}

			// Calculate points: product points * quantity
			pointsToAdd = product.Points * float64(input.Quantity)

			// Diminuer le stock du produit
			product.Stock = product.Stock - int(input.Quantity)
			_, err = r.Resolver.productService.Update(ctx, *input.ProductID, product)
			if err != nil {
				return nil, fmt.Errorf("échec de la mise à jour du stock: %w", err)
			}
		}
	}

	status := "pending"
	if input.Status != nil {
		status = *input.Status
	}

	// Validation pour le statut "partial"
	if status == "partial" {
		if input.PaidAmount == nil {
			return nil, errors.New("paidAmount est requis lorsque le statut est 'partial'")
		}
		if *input.PaidAmount <= 0 {
			return nil, errors.New("paidAmount doit être supérieur à 0")
		}
		if *input.PaidAmount >= input.Amount {
			return nil, errors.New("paidAmount doit être inférieur au montant total (amount)")
		}
	}

	m := &models.Sale{
		ClientID:   clientOID,
		ProductID:  productOID,
		Amount:     input.Amount,
		PaidAmount: input.PaidAmount,
		Quantity:   int(input.Quantity),
		Date:       time.Now(),
		Status:     status,
		Note:       input.Note,
	}
	created, err := r.Resolver.saleService.Create(ctx, m)
	if err != nil {
		return nil, err
	}

	// Ajouter les points au client selon le produit acheté et la quantité
	// Les points = points du produit × quantité achetée
	if input.ProductID != nil && *input.ProductID != "" && pointsToAdd > 0 {
		err = r.Resolver.clientService.AddPoints(ctx, input.ClientID, pointsToAdd)
		if err != nil {
			// Si l'ajout de points échoue, on retourne une erreur car c'est important
			return nil, fmt.Errorf("échec de l'ajout des points au client: %w", err)
		}
	}

	// Ajouter une entrée à la caisse pour cette vente
	// Si le statut est "paid", on ajoute le montant total
	// Si le statut est "partial", on ajoute seulement le paidAmount
	if created.Status == "paid" {
		saleRef := created.ID.Hex()
		refType := "sale"
		desc := fmt.Sprintf("Vente de produit - Client: %s", client.Name)
		caisseTransaction := &models.CaisseTransaction{
			Type:          "entree",
			Amount:        created.Amount,
			Description:   &desc,
			Reference:     &saleRef,
			ReferenceType: &refType,
		}
		_, err = r.Resolver.caisseService.AddTransaction(ctx, caisseTransaction)
		if err != nil {
			// Log error but don't fail the sale creation
			// In production, you might want to handle this differently
		}
	} else if created.Status == "partial" && created.PaidAmount != nil {
		saleRef := created.ID.Hex()
		refType := "sale"
		desc := fmt.Sprintf("Vente partielle - Client: %s (Montant payé: %.2f / %.2f)", client.Name, *created.PaidAmount, created.Amount)
		caisseTransaction := &models.CaisseTransaction{
			Type:          "entree",
			Amount:        *created.PaidAmount,
			Description:   &desc,
			Reference:     &saleRef,
			ReferenceType: &refType,
		}
		_, err = r.Resolver.caisseService.AddTransaction(ctx, caisseTransaction)
		if err != nil {
			// Log error but don't fail the sale creation
			// In production, you might want to handle this differently
		}
	}

	var prodIdStr *string
	if created.ProductID != nil {
		s := created.ProductID.Hex()
		prodIdStr = &s
	}
	return &model.Sale{
		ID:         created.ID.Hex(),
		ClientID:   created.ClientID.Hex(),
		ProductID:  prodIdStr,
		Amount:     created.Amount,
		PaidAmount: created.PaidAmount,
		Quantity:   int32(created.Quantity),
		Side:       created.Side,
		Date:       created.Date.Format(time.RFC3339),
		Status:     created.Status,
		Note:       created.Note,
	}, nil
}

// SaleUpdate is the resolver for the saleUpdate field.
func (r *mutationResolver) SaleUpdate(ctx context.Context, id string, input model.SaleInput) (*model.Sale, error) {
	// Validate ID
	if err := validation.ValidateObjectID(id); err != nil {
		return nil, err
	}

	// Validate input
	if err := validation.ValidateObjectID(input.ClientID); err != nil {
		return nil, err
	}
	if err := validation.ValidateObjectIDPtr(input.ProductID); err != nil {
		return nil, err
	}
	if err := validation.ValidateQuantity(input.Quantity); err != nil {
		return nil, err
	}
	if err := validation.ValidateAmountPositive(input.Amount); err != nil {
		return nil, err
	}
	if err := validation.ValidateAmountPtr(input.PaidAmount); err != nil {
		return nil, err
	}
	if input.Status != nil {
		if err := validation.ValidateSaleStatus(*input.Status); err != nil {
			return nil, err
		}
	}

	// Resolve client
	clientOID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, err
	}

	var productOID *primitive.ObjectID
	if input.ProductID != nil && *input.ProductID != "" {
		poid, err := primitive.ObjectIDFromHex(*input.ProductID)
		if err == nil {
			productOID = &poid
		}
	}
	status := "pending"
	if input.Status != nil {
		status = *input.Status
	}

	// Validation pour le statut "partial"
	if status == "partial" {
		if input.PaidAmount == nil {
			return nil, errors.New("paidAmount est requis lorsque le statut est 'partial'")
		}
		if *input.PaidAmount <= 0 {
			return nil, errors.New("paidAmount doit être supérieur à 0")
		}
		if *input.PaidAmount >= input.Amount {
			return nil, errors.New("paidAmount doit être inférieur au montant total (amount)")
		}
	}

	m := &models.Sale{
		ClientID:   clientOID,
		ProductID:  productOID,
		Amount:     input.Amount,
		PaidAmount: input.PaidAmount,
		Quantity:   int(input.Quantity),
		Status:     status,
		Note:       input.Note,
	}
	updated, err := r.Resolver.saleService.Update(ctx, id, m)
	if err != nil {
		return nil, err
	}
	var prodIdStr *string
	if updated.ProductID != nil {
		s := updated.ProductID.Hex()
		prodIdStr = &s
	}
	return &model.Sale{
		ID:         updated.ID.Hex(),
		ClientID:   updated.ClientID.Hex(),
		ProductID:  prodIdStr,
		Amount:     updated.Amount,
		PaidAmount: updated.PaidAmount,
		Quantity:   int32(updated.Quantity),
		Side:       updated.Side,
		Date:       updated.Date.Format(time.RFC3339),
		Status:     updated.Status,
		Note:       updated.Note,
	}, nil
}

// SaleDelete is the resolver for the saleDelete field.
func (r *mutationResolver) SaleDelete(ctx context.Context, id string) (bool, error) {
	if err := validation.ValidateObjectID(id); err != nil {
		return false, err
	}
	return r.Resolver.saleService.Delete(ctx, id)
}

// PaymentCreate is the resolver for the paymentCreate field.
func (r *mutationResolver) PaymentCreate(ctx context.Context, input model.PaymentInput) (*model.Payment, error) {
	// Validate input
	if err := validation.ValidateObjectID(input.ClientID); err != nil {
		return nil, err
	}
	if err := validation.ValidateAmountPositive(input.Amount); err != nil {
		return nil, err
	}
	if err := validation.ValidatePaymentMethod(input.Method); err != nil {
		return nil, err
	}

	clientOID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, err
	}
	p := &models.Payment{
		ClientID:    clientOID,
		Amount:      input.Amount,
		Date:        time.Now(),
		Method:      input.Method,
		Status:      "completed",
		Description: input.Description,
	}
	created, err := r.Resolver.paymentService.Create(ctx, p)
	if err != nil {
		return nil, err
	}

	// Ajouter une sortie à la caisse pour ce paiement
	paymentRef := created.ID.Hex()
	refType := "payment"
	client, err := r.Resolver.clientService.GetByID(ctx, input.ClientID)
	clientName := "Client inconnu"
	if err == nil && client != nil {
		clientName = client.Name
	}
	desc := fmt.Sprintf("Paiement client - %s", clientName)
	if input.Description != nil {
		desc = *input.Description
	}
	caisseTransaction := &models.CaisseTransaction{
		Type:          "sortie",
		Amount:        created.Amount,
		Description:   &desc,
		Reference:     &paymentRef,
		ReferenceType: &refType,
	}
	_, err = r.Resolver.caisseService.AddTransaction(ctx, caisseTransaction)
	if err != nil {
		// Log error but don't fail the payment creation
		// In production, you might want to handle this differently
	}

	return &model.Payment{
		ID: created.ID.Hex(), ClientID: created.ClientID.Hex(), Amount: created.Amount,
		Date: created.Date.Format(time.RFC3339), Method: created.Method, Status: created.Status, Description: created.Description,
	}, nil
}

// PaymentUpdate is the resolver for the paymentUpdate field.
func (r *mutationResolver) PaymentUpdate(ctx context.Context, id string, input model.PaymentInput) (*model.Payment, error) {
	// Validate ID
	if err := validation.ValidateObjectID(id); err != nil {
		return nil, err
	}

	// Validate input
	if err := validation.ValidateObjectID(input.ClientID); err != nil {
		return nil, err
	}
	if err := validation.ValidateAmountPositive(input.Amount); err != nil {
		return nil, err
	}
	if err := validation.ValidatePaymentMethod(input.Method); err != nil {
		return nil, err
	}

	clientOID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, err
	}
	p := &models.Payment{
		ClientID:    clientOID,
		Amount:      input.Amount,
		Method:      input.Method,
		Description: input.Description,
	}
	updated, err := r.Resolver.paymentService.Update(ctx, id, p)
	if err != nil {
		return nil, err
	}
	return &model.Payment{
		ID: updated.ID.Hex(), ClientID: updated.ClientID.Hex(), Amount: updated.Amount,
		Date: updated.Date.Format(time.RFC3339), Method: updated.Method, Status: updated.Status, Description: updated.Description,
	}, nil
}

// PaymentDelete is the resolver for the paymentDelete field.
func (r *mutationResolver) PaymentDelete(ctx context.Context, id string) (bool, error) {
	if err := validation.ValidateObjectID(id); err != nil {
		return false, err
	}
	return r.Resolver.paymentService.Delete(ctx, id)
}

// CommissionManualCreate is the resolver for the commissionManualCreate field.
func (r *mutationResolver) CommissionManualCreate(ctx context.Context, input model.CommissionInput) (*model.Commission, error) {
	// Validate input
	if err := validation.ValidateObjectID(input.ClientID); err != nil {
		return nil, err
	}
	if err := validation.ValidateObjectID(input.SourceClientID); err != nil {
		return nil, err
	}
	if err := validation.ValidateAmountPositive(input.Amount); err != nil {
		return nil, err
	}
	if err := validation.ValidateLevel(input.Level); err != nil {
		return nil, err
	}
	if err := validation.ValidateCommissionType(input.Type); err != nil {
		return nil, err
	}

	clientOID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, err
	}
	sourceOID, err := primitive.ObjectIDFromHex(input.SourceClientID)
	if err != nil {
		return nil, err
	}
	c := &models.Commission{
		ClientID:       clientOID,
		SourceClientID: sourceOID,
		Amount:         input.Amount,
		Level:          int(input.Level),
		Type:           input.Type,
		Date:           time.Now(),
	}
	created, err := r.Resolver.commissionService.Create(ctx, c)
	if err != nil {
		return nil, err
	}
	return &model.Commission{
		ID: created.ID.Hex(), ClientID: created.ClientID.Hex(), SourceClientID: created.SourceClientID.Hex(), Amount: created.Amount,
		Level: int32(created.Level), Type: created.Type, Date: created.Date.Format(time.RFC3339),
	}, nil
}

// RunBinaryCommissionCheck is the resolver for the runBinaryCommissionCheck field.
// Utilise le nouvel algorithme binaire amélioré
func (r *mutationResolver) RunBinaryCommissionCheck(ctx context.Context, clientID string) (*model.CommissionResult, error) {
	// Validate input
	if err := validation.ValidateObjectID(clientID); err != nil {
		return nil, err
	}

	// Utiliser le nouveau service d'algorithme binaire amélioré
	result, err := r.Resolver.binaryCommissionService.ComputeBinaryCommission(ctx, clientID)
	if err != nil {
		return nil, err
	}

	// Convertir le résultat en format CommissionResult
	commissionsCreated := int32(0)
	if result.Success && result.Qualified && result.CyclesPaid > 0 {
		commissionsCreated = 1
	}

	message := result.Reason
	if result.Success && result.Qualified && result.CyclesPaid > 0 {
		message = fmt.Sprintf("Commission binaire calculée: %d cycles payés, montant: %.2f$", result.CyclesPaid, result.Amount)
	}

	return &model.CommissionResult{
		CommissionsCreated: commissionsCreated,
		TotalAmount:        result.Amount,
		Message:            message,
	}, nil
}

// CaisseAddTransaction is the resolver for the caisseAddTransaction field.
func (r *mutationResolver) CaisseAddTransaction(ctx context.Context, input model.CaisseTransactionInput) (*model.CaisseTransaction, error) {
	// Validate input
	if err := validation.ValidateTransactionType(input.Type); err != nil {
		return nil, err
	}
	if err := validation.ValidateAmountPositive(input.Amount); err != nil {
		return nil, err
	}

	transaction := &models.CaisseTransaction{
		Type:          input.Type,
		Amount:        input.Amount,
		Description:   input.Description,
		Reference:     input.Reference,
		ReferenceType: input.ReferenceType,
	}

	created, err := r.Resolver.caisseService.AddTransaction(ctx, transaction)
	if err != nil {
		return nil, err
	}

	return &model.CaisseTransaction{
		ID:            created.ID.Hex(),
		Type:          created.Type,
		Amount:        created.Amount,
		Description:   created.Description,
		Reference:     created.Reference,
		ReferenceType: created.ReferenceType,
		Date:          created.Date.Format(time.RFC3339),
		CreatedBy:     created.CreatedBy,
	}, nil
}

// CaisseUpdateBalance is the resolver for the caisseUpdateBalance field.
func (r *mutationResolver) CaisseUpdateBalance(ctx context.Context, balance float64) (*model.Caisse, error) {
	// Validate input
	if err := validation.ValidateAmount(balance); err != nil {
		return nil, err
	}

	updated, err := r.Resolver.caisseService.UpdateBalance(ctx, balance)
	if err != nil {
		return nil, err
	}

	// Load transactions
	transactions, err := r.Resolver.caisseService.GetTransactions(ctx, nil, nil)
	if err != nil {
		transactions = []*models.CaisseTransaction{}
	}

	transactionsModel := make([]*model.CaisseTransaction, 0, len(transactions))
	for _, t := range transactions {
		transactionsModel = append(transactionsModel, &model.CaisseTransaction{
			ID:            t.ID.Hex(),
			Type:          t.Type,
			Amount:        t.Amount,
			Description:   t.Description,
			Reference:     t.Reference,
			ReferenceType: t.ReferenceType,
			Date:          t.Date.Format(time.RFC3339),
			CreatedBy:     t.CreatedBy,
		})
	}

	return &model.Caisse{
		ID:           updated.ID.Hex(),
		Balance:      updated.Balance,
		TotalEntrees: updated.TotalEntrees,
		TotalSorties: updated.TotalSorties,
		CreatedAt:    updated.CreatedAt.Format(time.RFC3339),
		UpdatedAt:    updated.UpdatedAt.Format(time.RFC3339),
		Transactions: transactionsModel,
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	// Try to read Authorization header from gqlgen operation context
	var token string
	if oc := graphql.GetOperationContext(ctx); oc != nil {
		if oc.Headers != nil {
			auth := oc.Headers.Get("Authorization")
			if strings.HasPrefix(strings.ToLower(auth), "bearer ") {
				token = strings.TrimSpace(auth[7:])
			}
		}
	}
	if token == "" {
		return nil, fmt.Errorf("unauthenticated")
	}
	admin, err := r.Resolver.authService.ValidateToken(ctx, token)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}
	return &model.User{
		ID:        admin.ID.Hex(),
		Name:      admin.Name,
		Email:     admin.Email,
		Role:      admin.Role,
		CreatedAt: admin.CreatedAt.Format(time.RFC3339),
	}, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.Product, error) {
	list, err := r.Resolver.productService.GetAll(ctx, nil, nil)
	if err != nil {
		return nil, err
	}
	out := make([]*model.Product, 0, len(list))
	for _, p := range list {
		out = append(out, &model.Product{
			ID: p.ID.Hex(), Name: p.Name, Description: p.Description, Price: p.Price, Stock: int32(p.Stock), Points: p.Points, ImageURL: p.ImageURL,
			CreatedAt: p.CreatedAt.Format(time.RFC3339), UpdatedAt: p.UpdatedAt.Format(time.RFC3339),
		})
	}
	return out, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id string) (*model.Product, error) {
	if err := validation.ValidateObjectID(id); err != nil {
		return nil, err
	}
	p, err := r.Resolver.productService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}
	return &model.Product{ID: p.ID.Hex(), Name: p.Name, Description: p.Description, Price: p.Price, Stock: int32(p.Stock), Points: p.Points, ImageURL: p.ImageURL, CreatedAt: p.CreatedAt.Format(time.RFC3339), UpdatedAt: p.UpdatedAt.Format(time.RFC3339)}, nil
}

// Clients is the resolver for the clients field.
func (r *queryResolver) Clients(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.Client, error) {
	// Convert GraphQL filter/paging to internal models
	var internalFilter *models.FilterInput
	if filter != nil {
		internalFilter = &models.FilterInput{
			Search:   filter.Search,
			Status:   filter.Status,
			DateFrom: nil, // Will need to parse if DateFrom/DateTo are provided
			DateTo:   nil,
		}
		// Parse date strings if provided
		if filter.DateFrom != nil {
			if t, err := time.Parse(time.RFC3339, *filter.DateFrom); err == nil {
				internalFilter.DateFrom = &t
			}
		}
		if filter.DateTo != nil {
			if t, err := time.Parse(time.RFC3339, *filter.DateTo); err == nil {
				internalFilter.DateTo = &t
			}
		}
	}
	var internalPaging *models.PagingInput
	if paging != nil {
		var page, limit *int
		if paging.Page != nil {
			p := int(*paging.Page)
			page = &p
		}
		if paging.Limit != nil {
			l := int(*paging.Limit)
			limit = &l
		}
		internalPaging = &models.PagingInput{
			Page:  page,
			Limit: limit,
		}
	}
	clients, err := r.Resolver.clientService.GetAll(ctx, internalFilter, internalPaging)
	if err != nil {
		return nil, err
	}

	// Only load basic client data - nested fields (sponsor, leftChild, rightChild, transactions, purchases)
	// will be loaded on-demand via field resolvers if requested in the GraphQL query
	out := make([]*model.Client, 0, len(clients))
	for _, c := range clients {
		mc := &model.Client{
			ID:                 c.ID.Hex(),
			ClientID:           c.ClientID,
			Name:               c.Name,
			Phone:              c.Phone,
			Nn:                 c.NN,
			Address:            c.Address,
			Avatar:             c.Avatar,
			JoinDate:           c.JoinDate.Format(time.RFC3339),
			Position:           c.Position,
			TotalEarnings:      c.TotalEarnings,
			WalletBalance:      c.WalletBalance,
			Points:             c.Points,
			NetworkVolumeLeft:  c.NetworkVolumeLeft,
			NetworkVolumeRight: c.NetworkVolumeRight,
			BinaryPairs:        int32(c.BinaryPairs),
		}
		if c.SponsorID != nil {
			sid := c.SponsorID.Hex()
			mc.SponsorID = &sid
		}
		if c.LeftChildID != nil {
			lid := c.LeftChildID.Hex()
			mc.LeftChildID = &lid
		}
		if c.RightChildID != nil {
			rid := c.RightChildID.Hex()
			mc.RightChildID = &rid
		}
		// Don't load nested data here - use field resolvers instead
		out = append(out, mc)
	}
	return out, nil
}

// Client is the resolver for the client field.
func (r *queryResolver) Client(ctx context.Context, id string) (*model.Client, error) {
	if err := validation.ValidateObjectID(id); err != nil {
		return nil, err
	}
	c, err := r.Resolver.clientService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}
	mc := &model.Client{
		ID:                 c.ID.Hex(),
		ClientID:           c.ClientID,
		Name:               c.Name,
		JoinDate:           c.JoinDate.Format(time.RFC3339),
		Position:           c.Position,
		TotalEarnings:      c.TotalEarnings,
		WalletBalance:      c.WalletBalance,
		Points:             c.Points,
		NetworkVolumeLeft:  c.NetworkVolumeLeft,
		NetworkVolumeRight: c.NetworkVolumeRight,
		BinaryPairs:        int32(c.BinaryPairs),
	}
	if c.SponsorID != nil {
		sid := c.SponsorID.Hex()
		mc.SponsorID = &sid
		sponsor, err := r.Resolver.clientService.GetByID(ctx, sid)
		if err == nil && sponsor != nil {
			mc.Sponsor = &model.Client{
				ID:          sponsor.ID.Hex(),
				ClientID:    sponsor.ClientID,
				Name:        sponsor.Name,
				Phone:       sponsor.Phone,
				Nn:          sponsor.NN,
				Address:     sponsor.Address,
				Avatar:      sponsor.Avatar,
				JoinDate:    sponsor.JoinDate.Format(time.RFC3339),
				Position:    sponsor.Position,
				BinaryPairs: int32(sponsor.BinaryPairs),
			}
		}
	}
	if c.LeftChildID != nil {
		lid := c.LeftChildID.Hex()
		mc.LeftChildID = &lid
		// hydrate left child
		leftChild, err := r.Resolver.clientService.GetByID(ctx, lid)
		if err == nil && leftChild != nil {
			mc.LeftChild = &model.Client{
				ID:          leftChild.ID.Hex(),
				ClientID:    leftChild.ClientID,
				Name:        leftChild.Name,
				Phone:       leftChild.Phone,
				Nn:          leftChild.NN,
				Address:     leftChild.Address,
				Avatar:      leftChild.Avatar,
				JoinDate:    leftChild.JoinDate.Format(time.RFC3339),
				Position:    leftChild.Position,
				BinaryPairs: int32(leftChild.BinaryPairs),
			}
		}
	}
	if c.RightChildID != nil {
		rid := c.RightChildID.Hex()
		mc.RightChildID = &rid
		// hydrate right child
		rightChild, err := r.Resolver.clientService.GetByID(ctx, rid)
		if err == nil && rightChild != nil {
			mc.RightChild = &model.Client{
				ID:          rightChild.ID.Hex(),
				ClientID:    rightChild.ClientID,
				Name:        rightChild.Name,
				Phone:       rightChild.Phone,
				Nn:          rightChild.NN,
				Address:     rightChild.Address,
				Avatar:      rightChild.Avatar,
				JoinDate:    rightChild.JoinDate.Format(time.RFC3339),
				Position:    rightChild.Position,
				BinaryPairs: int32(rightChild.BinaryPairs),
			}
		}
	}

	// Load transactions (payments)
	payments, err := r.Resolver.paymentService.GetByClientID(ctx, c.ID.Hex())
	if err == nil {
		mc.Transactions = make([]*model.Payment, 0, len(payments))
		for _, p := range payments {
			mc.Transactions = append(mc.Transactions, &model.Payment{
				ID:          p.ID.Hex(),
				ClientID:    p.ClientID.Hex(),
				Amount:      p.Amount,
				Date:        p.Date.Format(time.RFC3339),
				Method:      p.Method,
				Status:      p.Status,
				Description: p.Description,
			})
		}
	} else {
		mc.Transactions = []*model.Payment{}
	}

	// Load purchases (sales)
	sales, err := r.Resolver.saleService.GetByClientID(ctx, c.ID.Hex())
	if err == nil {
		mc.Purchases = make([]*model.Sale, 0, len(sales))
		for _, s := range sales {
			var prodIdStr *string
			if s.ProductID != nil {
				sid := s.ProductID.Hex()
				prodIdStr = &sid
			}
			mc.Purchases = append(mc.Purchases, &model.Sale{
				ID:        s.ID.Hex(),
				ClientID:  s.ClientID.Hex(),
				ProductID: prodIdStr,
				Amount:    s.Amount,
				Quantity:  int32(s.Quantity),
				Side:      s.Side,
				Date:      s.Date.Format(time.RFC3339),
				Status:    s.Status,
				Note:      s.Note,
			})
		}
	} else {
		mc.Purchases = []*model.Sale{}
	}

	return mc, nil
}

// ClientTree is the resolver for the clientTree field.
// Utilise maintenant GetSubtreeWithGraphLookup pour charger tout l'arbre en une seule requête optimisée
func (r *queryResolver) ClientTree(ctx context.Context, id string) (*model.ClientTree, error) {
	if err := validation.ValidateObjectID(id); err != nil {
		return nil, err
	}
	// Vérifier que le service client est disponible
	if r.Resolver.clientService == nil {
		return nil, fmt.Errorf("service client non disponible")
	}

	// Charger tout le sous-arbre en une seule requête optimisée avec $graphLookup
	clients, err := r.Resolver.clientService.GetSubtreeWithGraphLookup(ctx, id, 0) // 0 = pas de limite de profondeur
	if err != nil {
		return nil, fmt.Errorf("failed to load subtree: %w", err)
	}

	if len(clients) == 0 {
		return nil, fmt.Errorf("client introuvable: %s", id)
	}

	// Créer un index pour accès rapide O(1) par ID
	clientMap := make(map[string]*models.Client)
	var rootClient *models.Client
	for _, client := range clients {
		clientIDStr := client.ID.Hex()
		clientMap[clientIDStr] = client
		if clientIDStr == id {
			rootClient = client
		}
	}

	if rootClient == nil {
		return nil, fmt.Errorf("root client not found in subtree: %s", id)
	}

	// Cache pour les vérifications d'activité
	activeCache := make(map[string]bool)
	isClientActiveCached := func(clientID string) bool {
		if active, found := activeCache[clientID]; found {
			return active
		}
		if r.Resolver.binaryCommissionService == nil {
			activeCache[clientID] = false
			return false
		}
		active, err := r.Resolver.binaryCommissionService.IsClientActive(ctx, clientID)
		if err != nil {
			activeCache[clientID] = false
			return false
		}
		activeCache[clientID] = active
		return active
	}

	// Construire l'arbre en mémoire de manière optimisée (BFS)
	nodeMap := make(map[string]*model.ClientTreeNode)
	var allNodes []*model.ClientTreeNode
	maxLevel := 0

	type queueItem struct {
		client   *models.Client
		level    int
		parentID *string
		position *string
	}

	queue := []queueItem{{client: rootClient, level: 0, parentID: nil, position: nil}}
	visited := make(map[string]bool)

	// Parcourir l'arbre en BFS
	for len(queue) > 0 {
		item := queue[0]
		queue = queue[1:]

		clientIDStr := item.client.ID.Hex()
		if visited[clientIDStr] {
			continue
		}
		visited[clientIDStr] = true

		if item.level > maxLevel {
			maxLevel = item.level
		}

		// Créer le nœud
		node := &model.ClientTreeNode{
			ID:                 clientIDStr,
			ClientID:           item.client.ClientID,
			Name:               item.client.Name,
			Phone:              item.client.Phone,
			ParentID:           item.parentID,
			Level:              int32(item.level),
			Position:           item.position,
			NetworkVolumeLeft:  item.client.NetworkVolumeLeft,
			NetworkVolumeRight: item.client.NetworkVolumeRight,
			BinaryPairs:        int32(item.client.BinaryPairs),
			TotalEarnings:      item.client.TotalEarnings,
			WalletBalance:      item.client.WalletBalance,
			IsActive:           isClientActiveCached(clientIDStr),
			LeftActives:        0,
			RightActives:       0,
			IsQualified:        false,
		}

		// Enrichir avec les informations binaires seulement pour les 3 premiers niveaux
		if item.level < 3 {
			leftActives, rightActives := r.countActivesInLegs(ctx, item.client, activeCache, 3-item.level)
			node.LeftActives = int32(leftActives)
			node.RightActives = int32(rightActives)
			node.IsQualified = leftActives > 0 && rightActives > 0

			if leftActives > 0 && rightActives > 0 {
				if leftActives < rightActives {
					cycles := int32(leftActives)
					node.CyclesAvailable = &cycles
				} else {
					cycles := int32(rightActives)
					node.CyclesAvailable = &cycles
				}
			} else {
				zero := int32(0)
				node.CyclesAvailable = &zero
			}
		} else {
			zero := int32(0)
			node.CyclesAvailable = &zero
		}

		zero := int32(0)
		node.CyclesPaidToday = &zero

		nodeMap[clientIDStr] = node
		allNodes = append(allNodes, node)

		// Ajouter les enfants à la queue
		parentIDStr := clientIDStr
		if item.client.LeftChildID != nil {
			leftChildIDStr := item.client.LeftChildID.Hex()
			if leftChild, exists := clientMap[leftChildIDStr]; exists && !visited[leftChildIDStr] {
				leftPos := "left"
				queue = append(queue, queueItem{
					client:   leftChild,
					level:    item.level + 1,
					parentID: &parentIDStr,
					position: &leftPos,
				})
			}
		}
		if item.client.RightChildID != nil {
			rightChildIDStr := item.client.RightChildID.Hex()
			if rightChild, exists := clientMap[rightChildIDStr]; exists && !visited[rightChildIDStr] {
				rightPos := "right"
				queue = append(queue, queueItem{
					client:   rightChild,
					level:    item.level + 1,
					parentID: &parentIDStr,
					position: &rightPos,
				})
			}
		}
	}

	rootNode := nodeMap[id]
	if rootNode == nil {
		return nil, fmt.Errorf("root node not found after tree construction")
	}

	return &model.ClientTree{
		Root:       rootNode,
		Nodes:      allNodes,
		TotalNodes: int32(len(allNodes)),
		MaxLevel:   int32(maxLevel),
	}, nil
}

// countActivesInLegs compte les actifs dans chaque jambe avec limite de profondeur
func (r *queryResolver) countActivesInLegs(ctx context.Context, client *models.Client, activeCache map[string]bool, maxDepth int) (leftActives, rightActives int) {
	if maxDepth <= 0 {
		return 0, 0
	}

	if client.LeftChildID != nil {
		leftActives = r.countActivesInLeg(ctx, client.LeftChildID.Hex(), activeCache, maxDepth-1, 0)
	}
	if client.RightChildID != nil {
		rightActives = r.countActivesInLeg(ctx, client.RightChildID.Hex(), activeCache, maxDepth-1, 0)
	}

	return leftActives, rightActives
}

// countActivesInLeg compte récursivement les actifs dans une jambe
func (r *queryResolver) countActivesInLeg(ctx context.Context, clientID string, activeCache map[string]bool, maxDepth, currentDepth int) int {
	if maxDepth <= 0 {
		return 0
	}

	// Vérifier si le client est actif
	isActive := false
	if active, found := activeCache[clientID]; found {
		isActive = active
	} else {
		if r.Resolver.binaryCommissionService != nil {
			active, err := r.Resolver.binaryCommissionService.IsClientActive(ctx, clientID)
			if err == nil {
				isActive = active
			}
		}
		activeCache[clientID] = isActive
	}

	count := 0
	if isActive {
		count = 1
	}

	// Récupérer le client pour accéder aux enfants
	client, err := r.Resolver.clientService.GetByID(ctx, clientID)
	if err != nil {
		return count
	}

	// Compter les actifs dans les sous-arbres
	if client.LeftChildID != nil {
		count += r.countActivesInLeg(ctx, client.LeftChildID.Hex(), activeCache, maxDepth-1, currentDepth+1)
	}
	if client.RightChildID != nil {
		count += r.countActivesInLeg(ctx, client.RightChildID.Hex(), activeCache, maxDepth-1, currentDepth+1)
	}

	return count
}

// Sales is the resolver for the sales field.
func (r *queryResolver) Sales(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.Sale, error) {
	// Convert GraphQL model to internal model
	var filterModel *models.FilterInput
	if filter != nil {
		filterModel = &models.FilterInput{
			Search:   filter.Search,
			DateFrom: nil, // Convert if needed
			DateTo:   nil, // Convert if needed
			Status:   filter.Status,
		}
	}

	var pagingModel *models.PagingInput
	if paging != nil {
		var page *int
		var limit *int
		if paging.Page != nil {
			p := int(*paging.Page)
			page = &p
		}
		if paging.Limit != nil {
			l := int(*paging.Limit)
			limit = &l
		}
		pagingModel = &models.PagingInput{
			Page:  page,
			Limit: limit,
		}
	}

	sales, err := r.Resolver.saleService.GetAll(ctx, filterModel, pagingModel)
	if err != nil {
		return nil, err
	}

	out := make([]*model.Sale, 0, len(sales))
	for _, s := range sales {
		var prodIdStr *string
		if s.ProductID != nil {
			sid := s.ProductID.Hex()
			prodIdStr = &sid
		}

		sale := &model.Sale{
			ID:         s.ID.Hex(),
			ClientID:   s.ClientID.Hex(),
			ProductID:  prodIdStr,
			Amount:     s.Amount,
			PaidAmount: s.PaidAmount,
			Quantity:   int32(s.Quantity),
			Side:       s.Side,
			Date:       s.Date.Format(time.RFC3339),
			Status:     s.Status,
			Note:       s.Note,
		}

		// Hydrate client
		client, err := r.Resolver.clientService.GetByID(ctx, s.ClientID.Hex())
		if err == nil && client != nil {
			sale.Client = &model.Client{
				ID:                 client.ID.Hex(),
				ClientID:           client.ClientID,
				Name:               client.Name,
				Phone:              client.Phone,
				Nn:                 client.NN,
				Address:            client.Address,
				Avatar:             client.Avatar,
				SponsorID:          nil,
				Position:           client.Position,
				LeftChildID:        nil,
				RightChildID:       nil,
				JoinDate:           client.JoinDate.Format(time.RFC3339),
				TotalEarnings:      client.TotalEarnings,
				WalletBalance:      client.WalletBalance,
				Points:             client.Points,
				NetworkVolumeLeft:  client.NetworkVolumeLeft,
				NetworkVolumeRight: client.NetworkVolumeRight,
				BinaryPairs:        int32(client.BinaryPairs),
			}
			if client.SponsorID != nil {
				sid := client.SponsorID.Hex()
				sale.Client.SponsorID = &sid
			}
			if client.LeftChildID != nil {
				lid := client.LeftChildID.Hex()
				sale.Client.LeftChildID = &lid
			}
			if client.RightChildID != nil {
				rid := client.RightChildID.Hex()
				sale.Client.RightChildID = &rid
			}
		}

		// Hydrate product
		if s.ProductID != nil {
			product, err := r.Resolver.productService.GetByID(ctx, s.ProductID.Hex())
			if err == nil && product != nil {
				sale.Product = &model.Product{
					ID:          product.ID.Hex(),
					Name:        product.Name,
					Description: product.Description,
					Price:       product.Price,
					Stock:       int32(product.Stock),
					Points:      product.Points,
					ImageURL:    product.ImageURL,
					CreatedAt:   product.CreatedAt.Format(time.RFC3339),
					UpdatedAt:   product.UpdatedAt.Format(time.RFC3339),
				}
			}
		}

		out = append(out, sale)
	}
	return out, nil
}

// Sale is the resolver for the sale field.
func (r *queryResolver) Sale(ctx context.Context, id string) (*model.Sale, error) {
	if err := validation.ValidateObjectID(id); err != nil {
		return nil, err
	}
	s, err := r.Resolver.saleService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	var prodIdStr *string
	if s.ProductID != nil {
		sid := s.ProductID.Hex()
		prodIdStr = &sid
	}

	sale := &model.Sale{
		ID:         s.ID.Hex(),
		ClientID:   s.ClientID.Hex(),
		ProductID:  prodIdStr,
		Amount:     s.Amount,
		PaidAmount: s.PaidAmount,
		Quantity:   int32(s.Quantity),
		Side:       s.Side,
		Date:       s.Date.Format(time.RFC3339),
		Status:     s.Status,
		Note:       s.Note,
	}

	// Hydrate client
	client, err := r.Resolver.clientService.GetByID(ctx, s.ClientID.Hex())
	if err == nil && client != nil {
		sale.Client = &model.Client{
			ID:                 client.ID.Hex(),
			ClientID:           client.ClientID,
			Name:               client.Name,
			Phone:              client.Phone,
			Nn:                 client.NN,
			Address:            client.Address,
			Avatar:             client.Avatar,
			SponsorID:          nil,
			Position:           client.Position,
			LeftChildID:        nil,
			RightChildID:       nil,
			JoinDate:           client.JoinDate.Format(time.RFC3339),
			TotalEarnings:      client.TotalEarnings,
			WalletBalance:      client.WalletBalance,
			Points:             client.Points,
			NetworkVolumeLeft:  client.NetworkVolumeLeft,
			NetworkVolumeRight: client.NetworkVolumeRight,
			BinaryPairs:        int32(client.BinaryPairs),
		}
		if client.SponsorID != nil {
			sid := client.SponsorID.Hex()
			sale.Client.SponsorID = &sid
		}
		if client.LeftChildID != nil {
			lid := client.LeftChildID.Hex()
			sale.Client.LeftChildID = &lid
		}
		if client.RightChildID != nil {
			rid := client.RightChildID.Hex()
			sale.Client.RightChildID = &rid
		}
	}

	// Hydrate product
	if s.ProductID != nil {
		product, err := r.Resolver.productService.GetByID(ctx, s.ProductID.Hex())
		if err == nil && product != nil {
			sale.Product = &model.Product{
				ID:          product.ID.Hex(),
				Name:        product.Name,
				Description: product.Description,
				Price:       product.Price,
				Stock:       int32(product.Stock),
				Points:      product.Points,
				ImageURL:    product.ImageURL,
				CreatedAt:   product.CreatedAt.Format(time.RFC3339),
				UpdatedAt:   product.UpdatedAt.Format(time.RFC3339),
			}
		}
	}

	return sale, nil
}

// Payments is the resolver for the payments field.
func (r *queryResolver) Payments(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.Payment, error) {
	list, err := r.Resolver.paymentService.GetAll(ctx, nil, nil)
	if err != nil {
		return nil, err
	}
	out := make([]*model.Payment, 0, len(list))
	for _, p := range list {
		out = append(out, &model.Payment{ID: p.ID.Hex(), ClientID: p.ClientID.Hex(), Amount: p.Amount, Date: p.Date.Format(time.RFC3339), Method: p.Method, Status: p.Status, Description: p.Description})
	}
	return out, nil
}

// Payment is the resolver for the payment field.
func (r *queryResolver) Payment(ctx context.Context, id string) (*model.Payment, error) {
	if err := validation.ValidateObjectID(id); err != nil {
		return nil, err
	}
	p, err := r.Resolver.paymentService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}
	return &model.Payment{ID: p.ID.Hex(), ClientID: p.ClientID.Hex(), Amount: p.Amount, Date: p.Date.Format(time.RFC3339), Method: p.Method, Status: p.Status, Description: p.Description}, nil
}

// Commissions is the resolver for the commissions field.
func (r *queryResolver) Commissions(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.Commission, error) {
	list, err := r.Resolver.commissionService.GetAll(ctx, nil, nil)
	if err != nil {
		return nil, err
	}
	out := make([]*model.Commission, 0, len(list))
	for _, c := range list {
		out = append(out, &model.Commission{ID: c.ID.Hex(), ClientID: c.ClientID.Hex(), SourceClientID: c.SourceClientID.Hex(), Amount: c.Amount, Level: int32(c.Level), Type: c.Type, Date: c.Date.Format(time.RFC3339)})
	}
	return out, nil
}

// Commission is the resolver for the commission field.
func (r *queryResolver) Commission(ctx context.Context, id string) (*model.Commission, error) {
	if err := validation.ValidateObjectID(id); err != nil {
		return nil, err
	}
	c, err := r.Resolver.commissionService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}
	return &model.Commission{ID: c.ID.Hex(), ClientID: c.ClientID.Hex(), SourceClientID: c.SourceClientID.Hex(), Amount: c.Amount, Level: int32(c.Level), Type: c.Type, Date: c.Date.Format(time.RFC3339)}, nil
}

// DashboardStats is the resolver for the dashboardStats field.
func (r *queryResolver) DashboardStats(ctx context.Context, rangeArg *string) (*model.DashboardStats, error) {
	s, err := r.Resolver.adminService.GetDashboardStats(ctx, rangeArg)
	if err != nil {
		return nil, err
	}
	// Only load basic stats - heavy fields (monthlySales, networkGrowth, etc.) will be loaded via field resolvers if requested
	return &model.DashboardStats{
		TotalProducts:    int32(s.TotalProducts),
		TotalClients:     int32(s.TotalClients),
		TotalSales:       s.TotalSales,
		TotalCommissions: s.TotalCommissions,
		ActiveClients:    int32(s.ActiveClients),
		// Heavy fields will be loaded on-demand via field resolvers
	}, nil
}

// DashboardData is the resolver for the dashboardData field.
func (r *queryResolver) DashboardData(ctx context.Context) (*model.DashboardStats, error) {
	return r.DashboardStats(ctx, nil)
}

// Caisse is the resolver for the caisse field.
func (r *queryResolver) Caisse(ctx context.Context) (*model.Caisse, error) {
	caisse, err := r.Resolver.caisseService.GetCaisse(ctx)
	if err != nil {
		return nil, err
	}

	// Load transactions
	transactions, err := r.Resolver.caisseService.GetTransactions(ctx, nil, nil)
	if err != nil {
		transactions = []*models.CaisseTransaction{}
	}

	transactionsModel := make([]*model.CaisseTransaction, 0, len(transactions))
	for _, t := range transactions {
		transactionsModel = append(transactionsModel, &model.CaisseTransaction{
			ID:            t.ID.Hex(),
			Type:          t.Type,
			Amount:        t.Amount,
			Description:   t.Description,
			Reference:     t.Reference,
			ReferenceType: t.ReferenceType,
			Date:          t.Date.Format(time.RFC3339),
			CreatedBy:     t.CreatedBy,
		})
	}

	return &model.Caisse{
		ID:           caisse.ID.Hex(),
		Balance:      caisse.Balance,
		TotalEntrees: caisse.TotalEntrees,
		TotalSorties: caisse.TotalSorties,
		CreatedAt:    caisse.CreatedAt.Format(time.RFC3339),
		UpdatedAt:    caisse.UpdatedAt.Format(time.RFC3339),
		Transactions: transactionsModel,
	}, nil
}

// CaisseTransactions is the resolver for the caisseTransactions field.
func (r *queryResolver) CaisseTransactions(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.CaisseTransaction, error) {
	// Convert GraphQL model to internal model
	var filterModel *models.FilterInput
	if filter != nil {
		filterModel = &models.FilterInput{
			Search:   filter.Search,
			DateFrom: nil, // Convert if needed
			DateTo:   nil, // Convert if needed
			Status:   filter.Status,
		}
	}

	var pagingModel *models.PagingInput
	if paging != nil {
		var page *int
		var limit *int
		if paging.Page != nil {
			p := int(*paging.Page)
			page = &p
		}
		if paging.Limit != nil {
			l := int(*paging.Limit)
			limit = &l
		}
		pagingModel = &models.PagingInput{
			Page:  page,
			Limit: limit,
		}
	}

	transactions, err := r.Resolver.caisseService.GetTransactions(ctx, filterModel, pagingModel)
	if err != nil {
		return nil, err
	}

	out := make([]*model.CaisseTransaction, 0, len(transactions))
	for _, t := range transactions {
		out = append(out, &model.CaisseTransaction{
			ID:            t.ID.Hex(),
			Type:          t.Type,
			Amount:        t.Amount,
			Description:   t.Description,
			Reference:     t.Reference,
			ReferenceType: t.ReferenceType,
			Date:          t.Date.Format(time.RFC3339),
			CreatedBy:     t.CreatedBy,
		})
	}
	return out, nil
}

// OnNewSale is the resolver for the onNewSale field.
func (r *subscriptionResolver) OnNewSale(ctx context.Context) (<-chan *model.Sale, error) {
	ch := make(chan *model.Sale, 1)
	return ch, nil
}

// OnNewCommission is the resolver for the onNewCommission field.
func (r *subscriptionResolver) OnNewCommission(ctx context.Context) (<-chan *model.Commission, error) {
	ch := make(chan *model.Commission, 1)
	return ch, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
