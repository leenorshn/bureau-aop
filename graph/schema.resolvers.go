package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"bureau/graph/model"
	"bureau/internal/models"
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// UserLogin is the resolver for the userLogin field.
func (r *mutationResolver) UserLogin(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	ap, err := r.Resolver.authService.AdminLogin(ctx, input.Email, input.Password)
	if err != nil {
		return nil, err
	}
	user := &model.User{
		ID:    ap.Admin.ID.Hex(),
		Name:  ap.Admin.Name,
		Email: ap.Admin.Email,
		Role:  ap.Admin.Role,
		// CreatedAt omitted for brevity
	}
	return &model.AuthPayload{AccessToken: ap.AccessToken, RefreshToken: ap.RefreshToken, User: user}, nil
}

// ClientLogin is the resolver for the clientLogin field.
func (r *mutationResolver) ClientLogin(ctx context.Context, input model.ClientLoginInput) (*model.AuthPayload, error) {
	// Authenticate client by clientId/password
	c, err := r.Resolver.clientService.AuthenticateClient(ctx, input.ClientID, input.Password)
	if err != nil {
		return nil, err
	}
	// Generate client JWT tokens
	jwt := r.Resolver.authService.GetJWTService()
	access, err := jwt.GenerateClientAccessToken(c)
	if err != nil {
		return nil, err
	}
	refresh, err := jwt.GenerateClientRefreshToken(c)
	if err != nil {
		return nil, err
	}
	return &model.AuthPayload{
		AccessToken:  access,
		RefreshToken: refresh,
		User: &model.User{
			ID:        c.ID.Hex(),
			Name:      c.Name,
			Email:     "",
			Role:      "client",
			CreatedAt: "",
		},
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, input model.RefreshTokenInput) (*model.AuthPayload, error) {
	ap, err := r.Resolver.authService.RefreshToken(ctx, input.Token)
	if err != nil {
		return nil, err
	}
	user := &model.User{
		ID:    ap.Admin.ID.Hex(),
		Name:  ap.Admin.Name,
		Email: ap.Admin.Email,
		Role:  ap.Admin.Role,
	}
	return &model.AuthPayload{AccessToken: ap.AccessToken, RefreshToken: ap.RefreshToken, User: user}, nil
}

// ProductCreate is the resolver for the productCreate field.
func (r *mutationResolver) ProductCreate(ctx context.Context, input model.ProductInput) (*model.Product, error) {
	now := time.Now()
	p := &models.Product{
		Name:        input.Name,
		Description: input.Description,
		Price:       input.Price,
		Stock:       int(input.Stock),
		Points:      input.Points,
		ImageURL:    input.ImageURL,
		CreatedAt:   now,
		UpdatedAt:   now,
	}
	created, err := r.Resolver.productService.Create(ctx, p)
	if err != nil {
		return nil, err
	}
	return &model.Product{
		ID:          created.ID.Hex(),
		Name:        created.Name,
		Description: created.Description,
		Price:       created.Price,
		Stock:       int32(created.Stock),
		Points:      created.Points,
		ImageURL:    created.ImageURL,
		CreatedAt:   created.CreatedAt.Format(time.RFC3339),
		UpdatedAt:   created.UpdatedAt.Format(time.RFC3339),
	}, nil
}

// ProductUpdate is the resolver for the productUpdate field.
func (r *mutationResolver) ProductUpdate(ctx context.Context, id string, input model.ProductInput) (*model.Product, error) {
	now := time.Now()
	p := &models.Product{
		Name:        input.Name,
		Description: input.Description,
		Price:       input.Price,
		Stock:       int(input.Stock),
		Points:      input.Points,
		ImageURL:    input.ImageURL,
		UpdatedAt:   now,
	}
	updated, err := r.Resolver.productService.Update(ctx, id, p)
	if err != nil {
		return nil, err
	}
	return &model.Product{
		ID:          updated.ID.Hex(),
		Name:        updated.Name,
		Description: updated.Description,
		Price:       updated.Price,
		Stock:       int32(updated.Stock),
		Points:      updated.Points,
		ImageURL:    updated.ImageURL,
		CreatedAt:   updated.CreatedAt.Format(time.RFC3339),
		UpdatedAt:   updated.UpdatedAt.Format(time.RFC3339),
	}, nil
}

// ProductDelete is the resolver for the productDelete field.
func (r *mutationResolver) ProductDelete(ctx context.Context, id string) (bool, error) {
	return r.Resolver.productService.Delete(ctx, id)
}

// ClientCreate is the resolver for the clientCreate field.
func (r *mutationResolver) ClientCreate(ctx context.Context, input model.ClientInput) (*model.Client, error) {
	var sponsorOID *primitive.ObjectID
	if input.SponsorID != nil {
		oid, err := primitive.ObjectIDFromHex(*input.SponsorID)
		if err == nil {
			sponsorOID = &oid
		}
	}

	var requestedPosition *string
	if input.Position != nil && *input.Position != "" {
		requestedPosition = input.Position
	}

	now := time.Now()
	m := &models.Client{
		Name:         input.Name,
		PasswordHash: input.Password, // service will hash
		Phone:        input.Phone,
		NN:           input.Nn,
		Address:      input.Address,
		Avatar:       input.Avatar,
		JoinDate:     now,
	}
	created, err := r.Resolver.clientService.CreateWithBinaryPlacement(ctx, m, sponsorOID, requestedPosition)
	if err != nil {
		return nil, err
	}
	out := &model.Client{
		ID:                 created.ID.Hex(),
		ClientID:           created.ClientID,
		Name:               created.Name,
		Phone:              created.Phone,
		Nn:                 created.NN,
		Address:            created.Address,
		Avatar:             created.Avatar,
		JoinDate:           created.JoinDate.Format(time.RFC3339),
		Position:           created.Position,
		TotalEarnings:      created.TotalEarnings,
		WalletBalance:      created.WalletBalance,
		Points:             created.Points,
		NetworkVolumeLeft:  created.NetworkVolumeLeft,
		NetworkVolumeRight: created.NetworkVolumeRight,
		BinaryPairs:        int32(created.BinaryPairs),
	}
	if created.SponsorID != nil {
		sid := created.SponsorID.Hex()
		out.SponsorID = &sid
	}
	if created.LeftChildID != nil {
		lid := created.LeftChildID.Hex()
		out.LeftChildID = &lid
	}
	if created.RightChildID != nil {
		rid := created.RightChildID.Hex()
		out.RightChildID = &rid
	}
	return out, nil
}

// ClientUpdate is the resolver for the clientUpdate field.
func (r *mutationResolver) ClientUpdate(ctx context.Context, id string, input model.ClientInput) (*model.Client, error) {
	m := &models.Client{
		Name:    input.Name,
		Phone:   input.Phone,
		NN:      input.Nn,
		Address: input.Address,
		Avatar:  input.Avatar,
	}
	updated, err := r.Resolver.clientService.Update(ctx, id, m)
	if err != nil {
		return nil, err
	}
	out := &model.Client{
		ID:                 updated.ID.Hex(),
		ClientID:           updated.ClientID,
		Name:               updated.Name,
		Phone:              updated.Phone,
		Nn:                 updated.NN,
		Address:            updated.Address,
		Avatar:             updated.Avatar,
		JoinDate:           updated.JoinDate.Format(time.RFC3339),
		Position:           updated.Position,
		TotalEarnings:      updated.TotalEarnings,
		WalletBalance:      updated.WalletBalance,
		Points:             updated.Points,
		NetworkVolumeLeft:  updated.NetworkVolumeLeft,
		NetworkVolumeRight: updated.NetworkVolumeRight,
		BinaryPairs:        int32(updated.BinaryPairs),
	}
	if updated.SponsorID != nil {
		sid := updated.SponsorID.Hex()
		out.SponsorID = &sid
	}
	if updated.LeftChildID != nil {
		lid := updated.LeftChildID.Hex()
		out.LeftChildID = &lid
	}
	if updated.RightChildID != nil {
		rid := updated.RightChildID.Hex()
		out.RightChildID = &rid
	}
	return out, nil
}

// ClientDelete is the resolver for the clientDelete field.
func (r *mutationResolver) ClientDelete(ctx context.Context, id string) (bool, error) {
	return r.Resolver.clientService.Delete(ctx, id)
}

// SaleCreate is the resolver for the saleCreate field.
func (r *mutationResolver) SaleCreate(ctx context.Context, input model.SaleInput) (*model.Sale, error) {
	// Resolve client
	clientOID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, err
	}
	client, err := r.Resolver.clientService.GetByID(ctx, input.ClientID)
	if err != nil {
		return nil, err
	}

	// Resolve product and get points
	var productOID *primitive.ObjectID
	var pointsToAdd float64
	if input.ProductID != "" {
		poid, err := primitive.ObjectIDFromHex(input.ProductID)
		if err == nil {
			productOID = &poid
			// Get product to retrieve points and check stock
			product, err := r.Resolver.productService.GetByID(ctx, input.ProductID)
			if err != nil {
				return nil, fmt.Errorf("produit introuvable: %w", err)
			}
			if product == nil {
				return nil, errors.New("produit introuvable")
			}

			// Vérifier que le stock est suffisant
			if product.Stock < int(input.Quantity) {
				return nil, fmt.Errorf("stock insuffisant: disponible %d, demandé %d", product.Stock, input.Quantity)
			}

			// Calculate points: product points * quantity
			pointsToAdd = product.Points * float64(input.Quantity)

			// Diminuer le stock du produit
			product.Stock = product.Stock - int(input.Quantity)
			_, err = r.Resolver.productService.Update(ctx, input.ProductID, product)
			if err != nil {
				return nil, fmt.Errorf("échec de la mise à jour du stock: %w", err)
			}
		}
	}

	status := "pending"
	if input.Status != nil {
		status = *input.Status
	}

	// Validation pour le statut "partial"
	if status == "partial" {
		if input.PaidAmount == nil {
			return nil, errors.New("paidAmount est requis lorsque le statut est 'partial'")
		}
		if *input.PaidAmount <= 0 {
			return nil, errors.New("paidAmount doit être supérieur à 0")
		}
		if *input.PaidAmount >= input.Amount {
			return nil, errors.New("paidAmount doit être inférieur au montant total (amount)")
		}
	}

	m := &models.Sale{
		ClientID:   clientOID,
		ProductID:  productOID,
		Amount:     input.Amount,
		PaidAmount: input.PaidAmount,
		Quantity:   int(input.Quantity),
		Date:       time.Now(),
		Status:     status,
		Note:       input.Note,
	}
	created, err := r.Resolver.saleService.Create(ctx, m)
	if err != nil {
		return nil, err
	}

	// Ajouter les points au client selon le produit acheté et la quantité
	// Les points = points du produit × quantité achetée
	if input.ProductID != "" && pointsToAdd > 0 {
		err = r.Resolver.clientService.AddPoints(ctx, input.ClientID, pointsToAdd)
		if err != nil {
			// Si l'ajout de points échoue, on retourne une erreur car c'est important
			return nil, fmt.Errorf("échec de l'ajout des points au client: %w", err)
		}
	}

	// Ajouter une entrée à la caisse pour cette vente
	// Si le statut est "paid", on ajoute le montant total
	// Si le statut est "partial", on ajoute seulement le paidAmount
	if created.Status == "paid" {
		saleRef := created.ID.Hex()
		refType := "sale"
		desc := fmt.Sprintf("Vente de produit - Client: %s", client.Name)
		caisseTransaction := &models.CaisseTransaction{
			Type:          "entree",
			Amount:        created.Amount,
			Description:   &desc,
			Reference:     &saleRef,
			ReferenceType: &refType,
		}
		_, err = r.Resolver.caisseService.AddTransaction(ctx, caisseTransaction)
		if err != nil {
			// Log error but don't fail the sale creation
			// In production, you might want to handle this differently
		}
	} else if created.Status == "partial" && created.PaidAmount != nil {
		saleRef := created.ID.Hex()
		refType := "sale"
		desc := fmt.Sprintf("Vente partielle - Client: %s (Montant payé: %.2f / %.2f)", client.Name, *created.PaidAmount, created.Amount)
		caisseTransaction := &models.CaisseTransaction{
			Type:          "entree",
			Amount:        *created.PaidAmount,
			Description:   &desc,
			Reference:     &saleRef,
			ReferenceType: &refType,
		}
		_, err = r.Resolver.caisseService.AddTransaction(ctx, caisseTransaction)
		if err != nil {
			// Log error but don't fail the sale creation
			// In production, you might want to handle this differently
		}
	}

	var prodIdStr *string
	if created.ProductID != nil {
		s := created.ProductID.Hex()
		prodIdStr = &s
	}
	return &model.Sale{
		ID:         created.ID.Hex(),
		ClientID:   created.ClientID.Hex(),
		ProductID:  prodIdStr,
		Amount:     created.Amount,
		PaidAmount: created.PaidAmount,
		Quantity:   int32(created.Quantity),
		Side:       created.Side,
		Date:       created.Date.Format(time.RFC3339),
		Status:     created.Status,
		Note:       created.Note,
	}, nil
}

// SaleUpdate is the resolver for the saleUpdate field.
func (r *mutationResolver) SaleUpdate(ctx context.Context, id string, input model.SaleInput) (*model.Sale, error) {
	// Resolve client
	clientOID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, err
	}

	var productOID *primitive.ObjectID
	if input.ProductID != "" {
		poid, err := primitive.ObjectIDFromHex(input.ProductID)
		if err == nil {
			productOID = &poid
		}
	}
	status := "pending"
	if input.Status != nil {
		status = *input.Status
	}

	// Validation pour le statut "partial"
	if status == "partial" {
		if input.PaidAmount == nil {
			return nil, errors.New("paidAmount est requis lorsque le statut est 'partial'")
		}
		if *input.PaidAmount <= 0 {
			return nil, errors.New("paidAmount doit être supérieur à 0")
		}
		if *input.PaidAmount >= input.Amount {
			return nil, errors.New("paidAmount doit être inférieur au montant total (amount)")
		}
	}

	m := &models.Sale{
		ClientID:   clientOID,
		ProductID:  productOID,
		Amount:     input.Amount,
		PaidAmount: input.PaidAmount,
		Quantity:   int(input.Quantity),
		Status:     status,
		Note:       input.Note,
	}
	updated, err := r.Resolver.saleService.Update(ctx, id, m)
	if err != nil {
		return nil, err
	}
	var prodIdStr *string
	if updated.ProductID != nil {
		s := updated.ProductID.Hex()
		prodIdStr = &s
	}
	return &model.Sale{
		ID:         updated.ID.Hex(),
		ClientID:   updated.ClientID.Hex(),
		ProductID:  prodIdStr,
		Amount:     updated.Amount,
		PaidAmount: updated.PaidAmount,
		Quantity:   int32(updated.Quantity),
		Side:       updated.Side,
		Date:       updated.Date.Format(time.RFC3339),
		Status:     updated.Status,
		Note:       updated.Note,
	}, nil
}

// SaleDelete is the resolver for the saleDelete field.
func (r *mutationResolver) SaleDelete(ctx context.Context, id string) (bool, error) {
	return r.Resolver.saleService.Delete(ctx, id)
}

// PaymentCreate is the resolver for the paymentCreate field.
func (r *mutationResolver) PaymentCreate(ctx context.Context, input model.PaymentInput) (*model.Payment, error) {
	clientOID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, err
	}
	p := &models.Payment{
		ClientID:    clientOID,
		Amount:      input.Amount,
		Date:        time.Now(),
		Method:      input.Method,
		Status:      "completed",
		Description: input.Description,
	}
	created, err := r.Resolver.paymentService.Create(ctx, p)
	if err != nil {
		return nil, err
	}

	// Ajouter une sortie à la caisse pour ce paiement
	paymentRef := created.ID.Hex()
	refType := "payment"
	client, err := r.Resolver.clientService.GetByID(ctx, input.ClientID)
	clientName := "Client inconnu"
	if err == nil && client != nil {
		clientName = client.Name
	}
	desc := fmt.Sprintf("Paiement client - %s", clientName)
	if input.Description != nil {
		desc = *input.Description
	}
	caisseTransaction := &models.CaisseTransaction{
		Type:          "sortie",
		Amount:        created.Amount,
		Description:   &desc,
		Reference:     &paymentRef,
		ReferenceType: &refType,
	}
	_, err = r.Resolver.caisseService.AddTransaction(ctx, caisseTransaction)
	if err != nil {
		// Log error but don't fail the payment creation
		// In production, you might want to handle this differently
	}

	return &model.Payment{
		ID: created.ID.Hex(), ClientID: created.ClientID.Hex(), Amount: created.Amount,
		Date: created.Date.Format(time.RFC3339), Method: created.Method, Status: created.Status, Description: created.Description,
	}, nil
}

// PaymentUpdate is the resolver for the paymentUpdate field.
func (r *mutationResolver) PaymentUpdate(ctx context.Context, id string, input model.PaymentInput) (*model.Payment, error) {
	clientOID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, err
	}
	p := &models.Payment{
		ClientID:    clientOID,
		Amount:      input.Amount,
		Method:      input.Method,
		Description: input.Description,
	}
	updated, err := r.Resolver.paymentService.Update(ctx, id, p)
	if err != nil {
		return nil, err
	}
	return &model.Payment{
		ID: updated.ID.Hex(), ClientID: updated.ClientID.Hex(), Amount: updated.Amount,
		Date: updated.Date.Format(time.RFC3339), Method: updated.Method, Status: updated.Status, Description: updated.Description,
	}, nil
}

// PaymentDelete is the resolver for the paymentDelete field.
func (r *mutationResolver) PaymentDelete(ctx context.Context, id string) (bool, error) {
	return r.Resolver.paymentService.Delete(ctx, id)
}

// CommissionManualCreate is the resolver for the commissionManualCreate field.
func (r *mutationResolver) CommissionManualCreate(ctx context.Context, input model.CommissionInput) (*model.Commission, error) {
	clientOID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, err
	}
	sourceOID, err := primitive.ObjectIDFromHex(input.SourceClientID)
	if err != nil {
		return nil, err
	}
	c := &models.Commission{
		ClientID:       clientOID,
		SourceClientID: sourceOID,
		Amount:         input.Amount,
		Level:          int(input.Level),
		Type:           input.Type,
		Date:           time.Now(),
	}
	created, err := r.Resolver.commissionService.Create(ctx, c)
	if err != nil {
		return nil, err
	}
	return &model.Commission{
		ID: created.ID.Hex(), ClientID: created.ClientID.Hex(), SourceClientID: created.SourceClientID.Hex(), Amount: created.Amount,
		Level: int32(created.Level), Type: created.Type, Date: created.Date.Format(time.RFC3339),
	}, nil
}

// RunBinaryCommissionCheck is the resolver for the runBinaryCommissionCheck field.
// Utilise le nouvel algorithme binaire amélioré
func (r *mutationResolver) RunBinaryCommissionCheck(ctx context.Context, clientID string) (*model.CommissionResult, error) {
	// Utiliser le nouveau service d'algorithme binaire amélioré
	result, err := r.Resolver.binaryCommissionService.ComputeBinaryCommission(ctx, clientID)
	if err != nil {
		return nil, err
	}

	// Convertir le résultat en format CommissionResult
	commissionsCreated := int32(0)
	if result.Success && result.Qualified && result.CyclesPaid > 0 {
		commissionsCreated = 1
	}

	message := result.Reason
	if result.Success && result.Qualified && result.CyclesPaid > 0 {
		message = fmt.Sprintf("Commission binaire calculée: %d cycles payés, montant: %.2f$", result.CyclesPaid, result.Amount)
	}

	return &model.CommissionResult{
		CommissionsCreated: commissionsCreated,
		TotalAmount:        result.Amount,
		Message:            message,
	}, nil
}

// CaisseAddTransaction is the resolver for the caisseAddTransaction field.
func (r *mutationResolver) CaisseAddTransaction(ctx context.Context, input model.CaisseTransactionInput) (*model.CaisseTransaction, error) {
	transaction := &models.CaisseTransaction{
		Type:          input.Type,
		Amount:        input.Amount,
		Description:   input.Description,
		Reference:     input.Reference,
		ReferenceType: input.ReferenceType,
	}

	created, err := r.Resolver.caisseService.AddTransaction(ctx, transaction)
	if err != nil {
		return nil, err
	}

	return &model.CaisseTransaction{
		ID:            created.ID.Hex(),
		Type:          created.Type,
		Amount:        created.Amount,
		Description:   created.Description,
		Reference:     created.Reference,
		ReferenceType: created.ReferenceType,
		Date:          created.Date.Format(time.RFC3339),
		CreatedBy:     created.CreatedBy,
	}, nil
}

// CaisseUpdateBalance is the resolver for the caisseUpdateBalance field.
func (r *mutationResolver) CaisseUpdateBalance(ctx context.Context, balance float64) (*model.Caisse, error) {
	updated, err := r.Resolver.caisseService.UpdateBalance(ctx, balance)
	if err != nil {
		return nil, err
	}

	// Load transactions
	transactions, err := r.Resolver.caisseService.GetTransactions(ctx, nil, nil)
	if err != nil {
		transactions = []*models.CaisseTransaction{}
	}

	transactionsModel := make([]*model.CaisseTransaction, 0, len(transactions))
	for _, t := range transactions {
		transactionsModel = append(transactionsModel, &model.CaisseTransaction{
			ID:            t.ID.Hex(),
			Type:          t.Type,
			Amount:        t.Amount,
			Description:   t.Description,
			Reference:     t.Reference,
			ReferenceType: t.ReferenceType,
			Date:          t.Date.Format(time.RFC3339),
			CreatedBy:     t.CreatedBy,
		})
	}

	return &model.Caisse{
		ID:           updated.ID.Hex(),
		Balance:      updated.Balance,
		TotalEntrees: updated.TotalEntrees,
		TotalSorties: updated.TotalSorties,
		CreatedAt:    updated.CreatedAt.Format(time.RFC3339),
		UpdatedAt:    updated.UpdatedAt.Format(time.RFC3339),
		Transactions: transactionsModel,
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	// Try to read Authorization header from gqlgen operation context
	var token string
	if oc := graphql.GetOperationContext(ctx); oc != nil {
		if oc.Headers != nil {
			auth := oc.Headers.Get("Authorization")
			if strings.HasPrefix(strings.ToLower(auth), "bearer ") {
				token = strings.TrimSpace(auth[7:])
			}
		}
	}
	if token == "" {
		return nil, fmt.Errorf("unauthenticated")
	}
	admin, err := r.Resolver.authService.ValidateToken(ctx, token)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated")
	}
	return &model.User{
		ID:        admin.ID.Hex(),
		Name:      admin.Name,
		Email:     admin.Email,
		Role:      admin.Role,
		CreatedAt: admin.CreatedAt.Format(time.RFC3339),
	}, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.Product, error) {
	list, err := r.Resolver.productService.GetAll(ctx, nil, nil)
	if err != nil {
		return nil, err
	}
	out := make([]*model.Product, 0, len(list))
	for _, p := range list {
		out = append(out, &model.Product{
			ID: p.ID.Hex(), Name: p.Name, Description: p.Description, Price: p.Price, Stock: int32(p.Stock), Points: p.Points, ImageURL: p.ImageURL,
			CreatedAt: p.CreatedAt.Format(time.RFC3339), UpdatedAt: p.UpdatedAt.Format(time.RFC3339),
		})
	}
	return out, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id string) (*model.Product, error) {
	p, err := r.Resolver.productService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}
	return &model.Product{ID: p.ID.Hex(), Name: p.Name, Description: p.Description, Price: p.Price, Stock: int32(p.Stock), Points: p.Points, ImageURL: p.ImageURL, CreatedAt: p.CreatedAt.Format(time.RFC3339), UpdatedAt: p.UpdatedAt.Format(time.RFC3339)}, nil
}

// Clients is the resolver for the clients field.
func (r *queryResolver) Clients(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.Client, error) {
	// Convert GraphQL filter/paging to internal models
	var internalFilter *models.FilterInput
	if filter != nil {
		internalFilter = &models.FilterInput{
			Search:   filter.Search,
			Status:   filter.Status,
			DateFrom: nil, // Will need to parse if DateFrom/DateTo are provided
			DateTo:   nil,
		}
		// Parse date strings if provided
		if filter.DateFrom != nil {
			if t, err := time.Parse(time.RFC3339, *filter.DateFrom); err == nil {
				internalFilter.DateFrom = &t
			}
		}
		if filter.DateTo != nil {
			if t, err := time.Parse(time.RFC3339, *filter.DateTo); err == nil {
				internalFilter.DateTo = &t
			}
		}
	}
	var internalPaging *models.PagingInput
	if paging != nil {
		var page, limit *int
		if paging.Page != nil {
			p := int(*paging.Page)
			page = &p
		}
		if paging.Limit != nil {
			l := int(*paging.Limit)
			limit = &l
		}
		internalPaging = &models.PagingInput{
			Page:  page,
			Limit: limit,
		}
	}
	clients, err := r.Resolver.clientService.GetAll(ctx, internalFilter, internalPaging)
	if err != nil {
		return nil, err
	}

	// Only load basic client data - nested fields (sponsor, leftChild, rightChild, transactions, purchases)
	// will be loaded on-demand via field resolvers if requested in the GraphQL query
	out := make([]*model.Client, 0, len(clients))
	for _, c := range clients {
		mc := &model.Client{
			ID:                 c.ID.Hex(),
			ClientID:           c.ClientID,
			Name:               c.Name,
			Phone:              c.Phone,
			Nn:                 c.NN,
			Address:            c.Address,
			Avatar:             c.Avatar,
			JoinDate:           c.JoinDate.Format(time.RFC3339),
			Position:           c.Position,
			TotalEarnings:      c.TotalEarnings,
			WalletBalance:      c.WalletBalance,
			Points:             c.Points,
			NetworkVolumeLeft:  c.NetworkVolumeLeft,
			NetworkVolumeRight: c.NetworkVolumeRight,
			BinaryPairs:        int32(c.BinaryPairs),
		}
		if c.SponsorID != nil {
			sid := c.SponsorID.Hex()
			mc.SponsorID = &sid
		}
		if c.LeftChildID != nil {
			lid := c.LeftChildID.Hex()
			mc.LeftChildID = &lid
		}
		if c.RightChildID != nil {
			rid := c.RightChildID.Hex()
			mc.RightChildID = &rid
		}
		// Don't load nested data here - use field resolvers instead
		out = append(out, mc)
	}
	return out, nil
}

// Client is the resolver for the client field.
func (r *queryResolver) Client(ctx context.Context, id string) (*model.Client, error) {
	c, err := r.Resolver.clientService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}
	mc := &model.Client{
		ID:                 c.ID.Hex(),
		ClientID:           c.ClientID,
		Name:               c.Name,
		JoinDate:           c.JoinDate.Format(time.RFC3339),
		Position:           c.Position,
		TotalEarnings:      c.TotalEarnings,
		WalletBalance:      c.WalletBalance,
		Points:             c.Points,
		NetworkVolumeLeft:  c.NetworkVolumeLeft,
		NetworkVolumeRight: c.NetworkVolumeRight,
		BinaryPairs:        int32(c.BinaryPairs),
	}
	if c.SponsorID != nil {
		sid := c.SponsorID.Hex()
		mc.SponsorID = &sid
		sponsor, err := r.Resolver.clientService.GetByID(ctx, sid)
		if err == nil && sponsor != nil {
			mc.Sponsor = &model.Client{
				ID:          sponsor.ID.Hex(),
				ClientID:    sponsor.ClientID,
				Name:        sponsor.Name,
				Phone:       sponsor.Phone,
				Nn:          sponsor.NN,
				Address:     sponsor.Address,
				Avatar:      sponsor.Avatar,
				JoinDate:    sponsor.JoinDate.Format(time.RFC3339),
				Position:    sponsor.Position,
				BinaryPairs: int32(sponsor.BinaryPairs),
			}
		}
	}
	if c.LeftChildID != nil {
		lid := c.LeftChildID.Hex()
		mc.LeftChildID = &lid
		// hydrate left child
		leftChild, err := r.Resolver.clientService.GetByID(ctx, lid)
		if err == nil && leftChild != nil {
			mc.LeftChild = &model.Client{
				ID:          leftChild.ID.Hex(),
				ClientID:    leftChild.ClientID,
				Name:        leftChild.Name,
				Phone:       leftChild.Phone,
				Nn:          leftChild.NN,
				Address:     leftChild.Address,
				Avatar:      leftChild.Avatar,
				JoinDate:    leftChild.JoinDate.Format(time.RFC3339),
				Position:    leftChild.Position,
				BinaryPairs: int32(leftChild.BinaryPairs),
			}
		}
	}
	if c.RightChildID != nil {
		rid := c.RightChildID.Hex()
		mc.RightChildID = &rid
		// hydrate right child
		rightChild, err := r.Resolver.clientService.GetByID(ctx, rid)
		if err == nil && rightChild != nil {
			mc.RightChild = &model.Client{
				ID:          rightChild.ID.Hex(),
				ClientID:    rightChild.ClientID,
				Name:        rightChild.Name,
				Phone:       rightChild.Phone,
				Nn:          rightChild.NN,
				Address:     rightChild.Address,
				Avatar:      rightChild.Avatar,
				JoinDate:    rightChild.JoinDate.Format(time.RFC3339),
				Position:    rightChild.Position,
				BinaryPairs: int32(rightChild.BinaryPairs),
			}
		}
	}

	// Load transactions (payments)
	payments, err := r.Resolver.paymentService.GetByClientID(ctx, c.ID.Hex())
	if err == nil {
		mc.Transactions = make([]*model.Payment, 0, len(payments))
		for _, p := range payments {
			mc.Transactions = append(mc.Transactions, &model.Payment{
				ID:          p.ID.Hex(),
				ClientID:    p.ClientID.Hex(),
				Amount:      p.Amount,
				Date:        p.Date.Format(time.RFC3339),
				Method:      p.Method,
				Status:      p.Status,
				Description: p.Description,
			})
		}
	} else {
		mc.Transactions = []*model.Payment{}
	}

	// Load purchases (sales)
	sales, err := r.Resolver.saleService.GetByClientID(ctx, c.ID.Hex())
	if err == nil {
		mc.Purchases = make([]*model.Sale, 0, len(sales))
		for _, s := range sales {
			var prodIdStr *string
			if s.ProductID != nil {
				sid := s.ProductID.Hex()
				prodIdStr = &sid
			}
			mc.Purchases = append(mc.Purchases, &model.Sale{
				ID:        s.ID.Hex(),
				ClientID:  s.ClientID.Hex(),
				ProductID: prodIdStr,
				Amount:    s.Amount,
				Quantity:  int32(s.Quantity),
				Side:      s.Side,
				Date:      s.Date.Format(time.RFC3339),
				Status:    s.Status,
				Note:      s.Note,
			})
		}
	} else {
		mc.Purchases = []*model.Sale{}
	}

	return mc, nil
}

// ClientTree is the resolver for the clientTree field.
func (r *queryResolver) ClientTree(ctx context.Context, id string) (*model.ClientTree, error) {
	// Vérifier que le service client est disponible
	if r.Resolver.clientService == nil {
		return nil, fmt.Errorf("service client non disponible")
	}

	// Récupérer le client racine
	client, err := r.Resolver.clientService.GetByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("client introuvable: %w", err)
	}

	// Cache pour éviter les appels répétés à la DB
	// Map: clientID -> isActive
	activeCache := make(map[string]bool)
	
	// Fonction helper pour vérifier si un client est actif (avec cache)
	isClientActiveCached := func(clientID string) bool {
		if active, found := activeCache[clientID]; found {
			return active
		}
		if r.Resolver.binaryCommissionService == nil {
			activeCache[clientID] = false
			return false
		}
		active, err := r.Resolver.binaryCommissionService.IsClientActive(ctx, clientID)
		if err != nil {
			activeCache[clientID] = false
			return false
		}
		activeCache[clientID] = active
		return active
	}

	// Créer le nœud racine avec initialisation des champs obligatoires
	rootNode := &model.ClientTreeNode{
		ID:                client.ID.Hex(),
		ClientID:          client.ClientID,
		Name:              client.Name,
		Phone:             client.Phone,
		Level:             0,
		Position:          nil,
		ParentID:          nil,
		NetworkVolumeLeft: client.NetworkVolumeLeft,
		NetworkVolumeRight: client.NetworkVolumeRight,
		BinaryPairs:       int32(client.BinaryPairs),
		TotalEarnings:     client.TotalEarnings,
		WalletBalance:     client.WalletBalance,
		IsActive:          isClientActiveCached(client.ID.Hex()),
		LeftActives:       0,    // Sera mis à jour par enrichClientTreeNode
		RightActives:      0,    // Sera mis à jour par enrichClientTreeNode
		IsQualified:       false, // Sera mis à jour par enrichClientTreeNode
	}

	// Enrichir le nœud racine avec les informations binaires (seulement pour les 3 premiers niveaux)
	if err := r.enrichClientTreeNodeOptimized(ctx, rootNode, client, 0, 3, activeCache); err != nil {
		// Log l'erreur mais continue quand même avec les valeurs par défaut
		fmt.Printf("Erreur lors de l'enrichissement du nœud racine: %v\n", err)
	}

	// Collecter tous les descendants dans une liste plate
	nodes := []*model.ClientTreeNode{rootNode}
	maxLevel := 0

	// Parcourir l'arbre pour collecter tous les nœuds
	var collectTreeNodesHelper func(r *queryResolver, ctx context.Context, client *models.Client, level int, nodes *[]*model.ClientTreeNode, maxLevel *int, activeCache map[string]bool)
	collectTreeNodesHelper = func(r *queryResolver, ctx context.Context, client *models.Client, level int, nodes *[]*model.ClientTreeNode, maxLevel *int, activeCache map[string]bool) {
		currentLevel := level + 1
		if currentLevel > *maxLevel {
			*maxLevel = currentLevel
		}
		if client.LeftChildID != nil {
			leftChildID := client.LeftChildID.Hex()
			leftChild, err := r.Resolver.clientService.GetByID(ctx, leftChildID)
			if err == nil && leftChild != nil {
				parentID := client.ID.Hex()
				position := "left"
				node := &model.ClientTreeNode{
					ID:                leftChild.ID.Hex(),
					ClientID:          leftChild.ClientID,
					Name:             leftChild.Name,
					Phone:            leftChild.Phone,
					ParentID:         &parentID,
					Level:             int32(currentLevel),
					Position:         &position,
					NetworkVolumeLeft: leftChild.NetworkVolumeLeft,
					NetworkVolumeRight: leftChild.NetworkVolumeRight,
					BinaryPairs:       int32(leftChild.BinaryPairs),
					TotalEarnings:     leftChild.TotalEarnings,
					WalletBalance:     leftChild.WalletBalance,
					IsActive:          isClientActiveCached(leftChild.ID.Hex()),
					LeftActives:       0,    // Sera mis à jour par enrichClientTreeNode
					RightActives:      0,    // Sera mis à jour par enrichClientTreeNode
					IsQualified:       false, // Sera mis à jour par enrichClientTreeNode
				}
				// Enrichir le nœud avec les informations binaires (seulement pour les 3 premiers niveaux)
				if err := r.enrichClientTreeNodeOptimized(ctx, node, leftChild, currentLevel, 3, activeCache); err != nil {
					// Log l'erreur mais continue quand même avec les valeurs par défaut
					fmt.Printf("Erreur lors de l'enrichissement du nœud: %v\n", err)
				}
				*nodes = append(*nodes, node)
				collectTreeNodesHelper(r, ctx, leftChild, currentLevel, nodes, maxLevel, activeCache)
			}
		}
		if client.RightChildID != nil {
			rightChildID := client.RightChildID.Hex()
			rightChild, err := r.Resolver.clientService.GetByID(ctx, rightChildID)
			if err == nil && rightChild != nil {
				parentID := client.ID.Hex()
				position := "right"
				node := &model.ClientTreeNode{
					ID:                rightChild.ID.Hex(),
					ClientID:          rightChild.ClientID,
					Name:             rightChild.Name,
					Phone:            rightChild.Phone,
					ParentID:         &parentID,
					Level:             int32(currentLevel),
					Position:         &position,
					NetworkVolumeLeft: rightChild.NetworkVolumeLeft,
					NetworkVolumeRight: rightChild.NetworkVolumeRight,
					BinaryPairs:       int32(rightChild.BinaryPairs),
					TotalEarnings:     rightChild.TotalEarnings,
					WalletBalance:     rightChild.WalletBalance,
					IsActive:          isClientActiveCached(rightChild.ID.Hex()),
					LeftActives:       0,    // Sera mis à jour par enrichClientTreeNode
					RightActives:      0,    // Sera mis à jour par enrichClientTreeNode
					IsQualified:       false, // Sera mis à jour par enrichClientTreeNode
				}
				// Enrichir le nœud avec les informations binaires (seulement pour les 3 premiers niveaux)
				if err := r.enrichClientTreeNodeOptimized(ctx, node, rightChild, currentLevel, 3, activeCache); err != nil {
					// Log l'erreur mais continue quand même avec les valeurs par défaut
					fmt.Printf("Erreur lors de l'enrichissement du nœud: %v\n", err)
				}
				*nodes = append(*nodes, node)
				collectTreeNodesHelper(r, ctx, rightChild, currentLevel, nodes, maxLevel, activeCache)
			}
		}
	}
	collectTreeNodesHelper(r, ctx, client, 0, &nodes, &maxLevel, activeCache)

	return &model.ClientTree{
		Root:       rootNode,
		Nodes:      nodes,
		TotalNodes: int32(len(nodes)),
		MaxLevel:   int32(maxLevel),
	}, nil
}

// Sales is the resolver for the sales field.
func (r *queryResolver) Sales(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.Sale, error) {
	// Convert GraphQL model to internal model
	var filterModel *models.FilterInput
	if filter != nil {
		filterModel = &models.FilterInput{
			Search:   filter.Search,
			DateFrom: nil, // Convert if needed
			DateTo:   nil, // Convert if needed
			Status:   filter.Status,
		}
	}

	var pagingModel *models.PagingInput
	if paging != nil {
		var page *int
		var limit *int
		if paging.Page != nil {
			p := int(*paging.Page)
			page = &p
		}
		if paging.Limit != nil {
			l := int(*paging.Limit)
			limit = &l
		}
		pagingModel = &models.PagingInput{
			Page:  page,
			Limit: limit,
		}
	}

	sales, err := r.Resolver.saleService.GetAll(ctx, filterModel, pagingModel)
	if err != nil {
		return nil, err
	}

	out := make([]*model.Sale, 0, len(sales))
	for _, s := range sales {
		var prodIdStr *string
		if s.ProductID != nil {
			sid := s.ProductID.Hex()
			prodIdStr = &sid
		}

		sale := &model.Sale{
			ID:         s.ID.Hex(),
			ClientID:   s.ClientID.Hex(),
			ProductID:  prodIdStr,
			Amount:     s.Amount,
			PaidAmount: s.PaidAmount,
			Quantity:   int32(s.Quantity),
			Side:       s.Side,
			Date:       s.Date.Format(time.RFC3339),
			Status:     s.Status,
			Note:       s.Note,
		}

		// Hydrate client
		client, err := r.Resolver.clientService.GetByID(ctx, s.ClientID.Hex())
		if err == nil && client != nil {
			sale.Client = &model.Client{
				ID:                 client.ID.Hex(),
				ClientID:           client.ClientID,
				Name:               client.Name,
				Phone:              client.Phone,
				Nn:                 client.NN,
				Address:            client.Address,
				Avatar:             client.Avatar,
				SponsorID:          nil,
				Position:           client.Position,
				LeftChildID:        nil,
				RightChildID:       nil,
				JoinDate:           client.JoinDate.Format(time.RFC3339),
				TotalEarnings:      client.TotalEarnings,
				WalletBalance:      client.WalletBalance,
				Points:             client.Points,
				NetworkVolumeLeft:  client.NetworkVolumeLeft,
				NetworkVolumeRight: client.NetworkVolumeRight,
				BinaryPairs:        int32(client.BinaryPairs),
			}
			if client.SponsorID != nil {
				sid := client.SponsorID.Hex()
				sale.Client.SponsorID = &sid
			}
			if client.LeftChildID != nil {
				lid := client.LeftChildID.Hex()
				sale.Client.LeftChildID = &lid
			}
			if client.RightChildID != nil {
				rid := client.RightChildID.Hex()
				sale.Client.RightChildID = &rid
			}
		}

		// Hydrate product
		if s.ProductID != nil {
			product, err := r.Resolver.productService.GetByID(ctx, s.ProductID.Hex())
			if err == nil && product != nil {
				sale.Product = &model.Product{
					ID:          product.ID.Hex(),
					Name:        product.Name,
					Description: product.Description,
					Price:       product.Price,
					Stock:       int32(product.Stock),
					Points:      product.Points,
					ImageURL:    product.ImageURL,
					CreatedAt:   product.CreatedAt.Format(time.RFC3339),
					UpdatedAt:   product.UpdatedAt.Format(time.RFC3339),
				}
			}
		}

		out = append(out, sale)
	}
	return out, nil
}

// Sale is the resolver for the sale field.
func (r *queryResolver) Sale(ctx context.Context, id string) (*model.Sale, error) {
	s, err := r.Resolver.saleService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	var prodIdStr *string
	if s.ProductID != nil {
		sid := s.ProductID.Hex()
		prodIdStr = &sid
	}

	sale := &model.Sale{
		ID:         s.ID.Hex(),
		ClientID:   s.ClientID.Hex(),
		ProductID:  prodIdStr,
		Amount:     s.Amount,
		PaidAmount: s.PaidAmount,
		Quantity:   int32(s.Quantity),
		Side:       s.Side,
		Date:       s.Date.Format(time.RFC3339),
		Status:     s.Status,
		Note:       s.Note,
	}

	// Hydrate client
	client, err := r.Resolver.clientService.GetByID(ctx, s.ClientID.Hex())
	if err == nil && client != nil {
		sale.Client = &model.Client{
			ID:                 client.ID.Hex(),
			ClientID:           client.ClientID,
			Name:               client.Name,
			Phone:              client.Phone,
			Nn:                 client.NN,
			Address:            client.Address,
			Avatar:             client.Avatar,
			SponsorID:          nil,
			Position:           client.Position,
			LeftChildID:        nil,
			RightChildID:       nil,
			JoinDate:           client.JoinDate.Format(time.RFC3339),
			TotalEarnings:      client.TotalEarnings,
			WalletBalance:      client.WalletBalance,
			Points:             client.Points,
			NetworkVolumeLeft:  client.NetworkVolumeLeft,
			NetworkVolumeRight: client.NetworkVolumeRight,
			BinaryPairs:        int32(client.BinaryPairs),
		}
		if client.SponsorID != nil {
			sid := client.SponsorID.Hex()
			sale.Client.SponsorID = &sid
		}
		if client.LeftChildID != nil {
			lid := client.LeftChildID.Hex()
			sale.Client.LeftChildID = &lid
		}
		if client.RightChildID != nil {
			rid := client.RightChildID.Hex()
			sale.Client.RightChildID = &rid
		}
	}

	// Hydrate product
	if s.ProductID != nil {
		product, err := r.Resolver.productService.GetByID(ctx, s.ProductID.Hex())
		if err == nil && product != nil {
			sale.Product = &model.Product{
				ID:          product.ID.Hex(),
				Name:        product.Name,
				Description: product.Description,
				Price:       product.Price,
				Stock:       int32(product.Stock),
				Points:      product.Points,
				ImageURL:    product.ImageURL,
				CreatedAt:   product.CreatedAt.Format(time.RFC3339),
				UpdatedAt:   product.UpdatedAt.Format(time.RFC3339),
			}
		}
	}

	return sale, nil
}

// Payments is the resolver for the payments field.
func (r *queryResolver) Payments(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.Payment, error) {
	list, err := r.Resolver.paymentService.GetAll(ctx, nil, nil)
	if err != nil {
		return nil, err
	}
	out := make([]*model.Payment, 0, len(list))
	for _, p := range list {
		out = append(out, &model.Payment{ID: p.ID.Hex(), ClientID: p.ClientID.Hex(), Amount: p.Amount, Date: p.Date.Format(time.RFC3339), Method: p.Method, Status: p.Status, Description: p.Description})
	}
	return out, nil
}

// Payment is the resolver for the payment field.
func (r *queryResolver) Payment(ctx context.Context, id string) (*model.Payment, error) {
	p, err := r.Resolver.paymentService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}
	return &model.Payment{ID: p.ID.Hex(), ClientID: p.ClientID.Hex(), Amount: p.Amount, Date: p.Date.Format(time.RFC3339), Method: p.Method, Status: p.Status, Description: p.Description}, nil
}

// Commissions is the resolver for the commissions field.
func (r *queryResolver) Commissions(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.Commission, error) {
	list, err := r.Resolver.commissionService.GetAll(ctx, nil, nil)
	if err != nil {
		return nil, err
	}
	out := make([]*model.Commission, 0, len(list))
	for _, c := range list {
		out = append(out, &model.Commission{ID: c.ID.Hex(), ClientID: c.ClientID.Hex(), SourceClientID: c.SourceClientID.Hex(), Amount: c.Amount, Level: int32(c.Level), Type: c.Type, Date: c.Date.Format(time.RFC3339)})
	}
	return out, nil
}

// Commission is the resolver for the commission field.
func (r *queryResolver) Commission(ctx context.Context, id string) (*model.Commission, error) {
	c, err := r.Resolver.commissionService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}
	return &model.Commission{ID: c.ID.Hex(), ClientID: c.ClientID.Hex(), SourceClientID: c.SourceClientID.Hex(), Amount: c.Amount, Level: int32(c.Level), Type: c.Type, Date: c.Date.Format(time.RFC3339)}, nil
}

// DashboardStats is the resolver for the dashboardStats field.
func (r *queryResolver) DashboardStats(ctx context.Context, rangeArg *string) (*model.DashboardStats, error) {
	s, err := r.Resolver.adminService.GetDashboardStats(ctx, rangeArg)
	if err != nil {
		return nil, err
	}
	// Only load basic stats - heavy fields (monthlySales, networkGrowth, etc.) will be loaded via field resolvers if requested
	return &model.DashboardStats{
		TotalProducts:    int32(s.TotalProducts),
		TotalClients:     int32(s.TotalClients),
		TotalSales:       s.TotalSales,
		TotalCommissions: s.TotalCommissions,
		ActiveClients:    int32(s.ActiveClients),
		// Heavy fields will be loaded on-demand via field resolvers
	}, nil
}

// DashboardData is the resolver for the dashboardData field.
func (r *queryResolver) DashboardData(ctx context.Context) (*model.DashboardStats, error) {
	return r.DashboardStats(ctx, nil)
}

// Caisse is the resolver for the caisse field.
func (r *queryResolver) Caisse(ctx context.Context) (*model.Caisse, error) {
	caisse, err := r.Resolver.caisseService.GetCaisse(ctx)
	if err != nil {
		return nil, err
	}

	// Load transactions
	transactions, err := r.Resolver.caisseService.GetTransactions(ctx, nil, nil)
	if err != nil {
		transactions = []*models.CaisseTransaction{}
	}

	transactionsModel := make([]*model.CaisseTransaction, 0, len(transactions))
	for _, t := range transactions {
		transactionsModel = append(transactionsModel, &model.CaisseTransaction{
			ID:            t.ID.Hex(),
			Type:          t.Type,
			Amount:        t.Amount,
			Description:   t.Description,
			Reference:     t.Reference,
			ReferenceType: t.ReferenceType,
			Date:          t.Date.Format(time.RFC3339),
			CreatedBy:     t.CreatedBy,
		})
	}

	return &model.Caisse{
		ID:           caisse.ID.Hex(),
		Balance:      caisse.Balance,
		TotalEntrees: caisse.TotalEntrees,
		TotalSorties: caisse.TotalSorties,
		CreatedAt:    caisse.CreatedAt.Format(time.RFC3339),
		UpdatedAt:    caisse.UpdatedAt.Format(time.RFC3339),
		Transactions: transactionsModel,
	}, nil
}

// CaisseTransactions is the resolver for the caisseTransactions field.
func (r *queryResolver) CaisseTransactions(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.CaisseTransaction, error) {
	// Convert GraphQL model to internal model
	var filterModel *models.FilterInput
	if filter != nil {
		filterModel = &models.FilterInput{
			Search:   filter.Search,
			DateFrom: nil, // Convert if needed
			DateTo:   nil, // Convert if needed
			Status:   filter.Status,
		}
	}

	var pagingModel *models.PagingInput
	if paging != nil {
		var page *int
		var limit *int
		if paging.Page != nil {
			p := int(*paging.Page)
			page = &p
		}
		if paging.Limit != nil {
			l := int(*paging.Limit)
			limit = &l
		}
		pagingModel = &models.PagingInput{
			Page:  page,
			Limit: limit,
		}
	}

	transactions, err := r.Resolver.caisseService.GetTransactions(ctx, filterModel, pagingModel)
	if err != nil {
		return nil, err
	}

	out := make([]*model.CaisseTransaction, 0, len(transactions))
	for _, t := range transactions {
		out = append(out, &model.CaisseTransaction{
			ID:            t.ID.Hex(),
			Type:          t.Type,
			Amount:        t.Amount,
			Description:   t.Description,
			Reference:     t.Reference,
			ReferenceType: t.ReferenceType,
			Date:          t.Date.Format(time.RFC3339),
			CreatedBy:     t.CreatedBy,
		})
	}
	return out, nil
}

// OnNewSale is the resolver for the onNewSale field.
func (r *subscriptionResolver) OnNewSale(ctx context.Context) (<-chan *model.Sale, error) {
	ch := make(chan *model.Sale, 1)
	return ch, nil
}

// OnNewCommission is the resolver for the onNewCommission field.
func (r *subscriptionResolver) OnNewCommission(ctx context.Context) (<-chan *model.Commission, error) {
	ch := make(chan *model.Commission, 1)
	return ch, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

// enrichClientTreeNode enrichit un ClientTreeNode avec les informations binaires
func (r *queryResolver) enrichClientTreeNode(ctx context.Context, node *model.ClientTreeNode, client *models.Client) error {
	return r.enrichClientTreeNodeOptimized(ctx, node, client, 0, 3, make(map[string]bool))
}

// enrichClientTreeNodeOptimized enrichit un ClientTreeNode avec les informations binaires (version optimisée)
// maxDepthForActives: limite la profondeur pour le calcul des actifs (0 = pas de limite, 3 = seulement 3 niveaux)
func (r *queryResolver) enrichClientTreeNodeOptimized(ctx context.Context, node *model.ClientTreeNode, client *models.Client, currentLevel int, maxDepthForActives int, activeCache map[string]bool) error {
	// Vérifier que le service est disponible
	if r.Resolver.binaryCommissionService == nil {
		// Si le service n'est pas disponible, on garde les valeurs par défaut déjà initialisées
		zero := int32(0)
		node.CyclesAvailable = &zero
		node.CyclesPaidToday = &zero
		return fmt.Errorf("binaryCommissionService n'est pas disponible")
	}

	// Récupérer les informations de base du client (déjà initialisées, mais on les met à jour au cas où)
	node.NetworkVolumeLeft = client.NetworkVolumeLeft
	node.NetworkVolumeRight = client.NetworkVolumeRight
	node.BinaryPairs = int32(client.BinaryPairs)
	node.TotalEarnings = client.TotalEarnings
	node.WalletBalance = client.WalletBalance

	// IsActive est déjà mis à jour via le cache dans ClientTree

	// Calculer le nombre d'actifs dans chaque jambe SEULEMENT si on est dans les premiers niveaux
	// Pour les niveaux plus profonds, on met 0 pour éviter les calculs coûteux
	if maxDepthForActives == 0 || currentLevel < maxDepthForActives {
		// Utiliser la version optimisée avec cache
		remainingDepth := maxDepthForActives - currentLevel
		if remainingDepth < 0 {
			remainingDepth = 0
		}
		legs, err := r.Resolver.binaryCommissionService.GetLegsVolumesWithCache(ctx, client, activeCache, remainingDepth)
		if err == nil && legs != nil {
			node.LeftActives = int32(legs.LeftActives)
			node.RightActives = int32(legs.RightActives)
		} else {
			// En cas d'erreur, on met 0 pour éviter de bloquer la requête
			node.LeftActives = 0
			node.RightActives = 0
		}
	} else {
		// Pour les niveaux profonds, on ne calcule pas les actifs (trop coûteux)
		node.LeftActives = 0
		node.RightActives = 0
	}

	// Vérifier la qualification (seulement si on a calculé les actifs)
	if maxDepthForActives == 0 || currentLevel < maxDepthForActives {
		qualification, err := r.Resolver.binaryCommissionService.CheckQualification(ctx, client)
		if err == nil && qualification != nil {
			node.IsQualified = qualification.IsQualified
		} else {
			node.IsQualified = false
		}
	} else {
		// Pour les niveaux profonds, on ne vérifie pas la qualification
		node.IsQualified = false
	}

	// Calculer les cycles disponibles
	if node.LeftActives > 0 && node.RightActives > 0 {
		if node.LeftActives < node.RightActives {
			cyclesInt32 := node.LeftActives
			node.CyclesAvailable = &cyclesInt32
		} else {
			cyclesInt32 := node.RightActives
			node.CyclesAvailable = &cyclesInt32
		}
	} else {
		zero := int32(0)
		node.CyclesAvailable = &zero
	}

	// Récupérer les cycles payés aujourd'hui (seulement pour les premiers niveaux pour éviter trop d'appels DB)
	// On évite cette opération pour les niveaux profonds car elle peut être coûteuse
	if (maxDepthForActives == 0 || currentLevel < maxDepthForActives) && r.Resolver.binaryCommissionService != nil {
		today := time.Now().Truncate(24 * time.Hour)
		capping, err := r.Resolver.binaryCommissionService.GetOrCreateCapping(ctx, client.ID, today)
		if err == nil && capping != nil {
			cyclesPaid := int32(capping.CyclesPaidToday)
			node.CyclesPaidToday = &cyclesPaid
		} else {
			// En cas d'erreur, on met 0 pour ne pas bloquer la requête
			zero := int32(0)
			node.CyclesPaidToday = &zero
		}
	} else {
		// Pour les niveaux profonds ou si le service n'est pas disponible, on met 0
		zero := int32(0)
		node.CyclesPaidToday = &zero
	}

	return nil
}
