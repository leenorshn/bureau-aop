package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"bureau/graph/model"
	"bureau/internal/models"
	"context"
	"fmt"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

// UserLogin is the resolver for the userLogin field.
func (r *mutationResolver) UserLogin(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	authPayload, err := r.Resolver.authService.AdminLogin(ctx, input.Email, input.Password)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		AccessToken:  authPayload.AccessToken,
		RefreshToken: authPayload.RefreshToken,
		User: &model.User{
			ID:    authPayload.Admin.ID.Hex(),
			Email: authPayload.Admin.Email,
			Name:  authPayload.Admin.Name,
		},
	}, nil
}

// ClientLogin is the resolver for the clientLogin field.
func (r *mutationResolver) ClientLogin(ctx context.Context, input model.ClientLoginInput) (*model.AuthPayload, error) {
	client, err := r.Resolver.clientService.AuthenticateClient(ctx, input.ClientID, input.Password)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		AccessToken:  "",
		RefreshToken: "",
		User: &model.User{
			ID:        client.ID.Hex(),
			Name:      client.Name,
			Email:     "",
			Role:      "client",
			CreatedAt: "",
		},
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, input model.RefreshTokenInput) (*model.AuthPayload, error) {
	authPayload, err := r.Resolver.authService.RefreshToken(ctx, input.Token)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		AccessToken:  authPayload.AccessToken,
		RefreshToken: authPayload.RefreshToken,
		User: &model.User{
			ID:    authPayload.Admin.ID.Hex(),
			Email: authPayload.Admin.Email,
			Name:  authPayload.Admin.Name,
		},
	}, nil
}

// ProductCreate is the resolver for the productCreate field.
func (r *mutationResolver) ProductCreate(ctx context.Context, input model.ProductInput) (*model.Product, error) {
	product := &models.Product{
		Name:        input.Name,
		Description: input.Description,
		Price:       input.Price,
		Stock:       int(input.Stock),
		ImageURL:    input.ImageURL,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	createdProduct, err := r.Resolver.productService.Create(ctx, product)
	if err != nil {
		return nil, err
	}

	return &model.Product{
		ID:          createdProduct.ID.Hex(),
		Name:        createdProduct.Name,
		Description: createdProduct.Description,
		Price:       createdProduct.Price,
		Stock:       int32(createdProduct.Stock),
		ImageURL:    createdProduct.ImageURL,
		CreatedAt:   createdProduct.CreatedAt.Format(time.RFC3339),
		UpdatedAt:   createdProduct.UpdatedAt.Format(time.RFC3339),
	}, nil
}

// ProductUpdate is the resolver for the productUpdate field.
func (r *mutationResolver) ProductUpdate(ctx context.Context, id string, input model.ProductInput) (*model.Product, error) {
	product := &models.Product{
		Name:        input.Name,
		Description: input.Description,
		Price:       input.Price,
		Stock:       int(input.Stock),
		ImageURL:    input.ImageURL,
		UpdatedAt:   time.Now(),
	}

	updatedProduct, err := r.Resolver.productService.Update(ctx, id, product)
	if err != nil {
		return nil, err
	}

	return &model.Product{
		ID:          updatedProduct.ID.Hex(),
		Name:        updatedProduct.Name,
		Description: updatedProduct.Description,
		Price:       updatedProduct.Price,
		Stock:       int32(updatedProduct.Stock),
		ImageURL:    updatedProduct.ImageURL,
		CreatedAt:   updatedProduct.CreatedAt.Format(time.RFC3339),
		UpdatedAt:   updatedProduct.UpdatedAt.Format(time.RFC3339),
	}, nil
}

// ProductDelete is the resolver for the productDelete field.
func (r *mutationResolver) ProductDelete(ctx context.Context, id string) (bool, error) {
	success, err := r.Resolver.productService.Delete(ctx, id)
	if err != nil {
		return false, err
	}

	return success, nil
}

// ClientCreate is the resolver for the clientCreate field.
func (r *mutationResolver) ClientCreate(ctx context.Context, input model.ClientInput) (*model.Client, error) {
	// Convert sponsor ID to ObjectID if provided
	var sponsorID *primitive.ObjectID
	if input.SponsorID != nil {
		sponsorObjID, err := primitive.ObjectIDFromHex(*input.SponsorID)
		if err != nil {
			return nil, fmt.Errorf("invalid sponsor ID: %w", err)
		}
		sponsorID = &sponsorObjID
	}

	client := &models.Client{
		Name:         input.Name,
		PasswordHash: input.Password, // This should be hashed in the service
		SponsorID:    sponsorID,
		JoinDate:     time.Now(),
	}

	createdClient, err := r.Resolver.clientService.CreateWithBinaryPlacement(ctx, client, sponsorID)
	if err != nil {
		return nil, err
	}

	return &model.Client{
		ID:           createdClient.ID.Hex(),
		Name:         createdClient.Name,
		SponsorID:    convertObjectIDToString(createdClient.SponsorID),
		LeftChildID:  convertObjectIDToString(createdClient.LeftChildID),
		RightChildID: convertObjectIDToString(createdClient.RightChildID),
	}, nil
}

// ClientUpdate is the resolver for the clientUpdate field.
func (r *mutationResolver) ClientUpdate(ctx context.Context, id string, input model.ClientInput) (*model.Client, error) {
	// Convert sponsor ID to ObjectID if provided
	var sponsorID *primitive.ObjectID
	if input.SponsorID != nil {
		sponsorObjID, err := primitive.ObjectIDFromHex(*input.SponsorID)
		if err != nil {
			return nil, fmt.Errorf("invalid sponsor ID: %w", err)
		}
		sponsorID = &sponsorObjID
	}

	client := &models.Client{
		Name:      input.Name,
		SponsorID: sponsorID,
	}

	updatedClient, err := r.Resolver.clientService.Update(ctx, id, client)
	if err != nil {
		return nil, err
	}

	return &model.Client{
		ID:           updatedClient.ID.Hex(),
		Name:         updatedClient.Name,
		SponsorID:    convertObjectIDToString(updatedClient.SponsorID),
		LeftChildID:  convertObjectIDToString(updatedClient.LeftChildID),
		RightChildID: convertObjectIDToString(updatedClient.RightChildID),
	}, nil
}

// ClientDelete is the resolver for the clientDelete field.
func (r *mutationResolver) ClientDelete(ctx context.Context, id string) (bool, error) {
	success, err := r.Resolver.clientService.Delete(ctx, id)
	if err != nil {
		return false, err
	}

	return success, nil
}

// SaleCreate is the resolver for the saleCreate field.
func (r *mutationResolver) SaleCreate(ctx context.Context, input model.SaleInput) (*model.Sale, error) {
	// Convert client ID to ObjectID
	clientID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, fmt.Errorf("invalid client ID: %w", err)
	}

	// Get client to find sponsor
	client, err := r.Resolver.clientService.GetByID(ctx, input.ClientID)
	if err != nil {
		return nil, fmt.Errorf("client not found: %w", err)
	}

	// Convert product ID to ObjectID
	productObjID, err := primitive.ObjectIDFromHex(input.ProductID)
	if err != nil {
		return nil, fmt.Errorf("invalid product ID: %w", err)
	}
	productID := &productObjID

	// Create sale using internal model
	var sponsorID primitive.ObjectID
	if client.SponsorID != nil {
		sponsorID = *client.SponsorID
	} else {
		sponsorID = clientID // Use client ID as sponsor if no sponsor
	}

	// Set default status if not provided
	status := "pending"
	if input.Status != nil {
		status = *input.Status
	}

	sale := &models.Sale{
		ClientID:  clientID,
		SponsorID: sponsorID,
		ProductID: productID,
		Amount:    input.Amount,
		Quantity:  int(input.Quantity),
		Date:      time.Now(),
		Status:    status,
		Note:      input.Note,
	}

	createdSale, err := r.Resolver.saleService.Create(ctx, sale)
	if err != nil {
		return nil, err
	}

	// Convert internal model to GraphQL model
	return &model.Sale{
		ID:        createdSale.ID.Hex(),
		ClientID:  createdSale.ClientID.Hex(),
		SponsorID: createdSale.SponsorID.Hex(),
		ProductID: convertObjectIDToString(createdSale.ProductID),
		Amount:    createdSale.Amount,
		Quantity:  int32(createdSale.Quantity),
		Side:      createdSale.Side,
		Date:      createdSale.Date.Format(time.RFC3339),
		Status:    createdSale.Status,
		Note:      createdSale.Note,
	}, nil
}

// SaleUpdate is the resolver for the saleUpdate field.
func (r *mutationResolver) SaleUpdate(ctx context.Context, id string, input model.SaleInput) (*model.Sale, error) {
	// Convert sale ID to ObjectID
	saleID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, fmt.Errorf("invalid sale ID: %w", err)
	}

	// Convert client ID to ObjectID
	clientID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, fmt.Errorf("invalid client ID: %w", err)
	}

	// Get client to find sponsor
	client, err := r.Resolver.clientService.GetByID(ctx, input.ClientID)
	if err != nil {
		return nil, fmt.Errorf("client not found: %w", err)
	}

	// Convert product ID to ObjectID (now required)
	productObjID, err := primitive.ObjectIDFromHex(input.ProductID)
	if err != nil {
		return nil, fmt.Errorf("invalid product ID: %w", err)
	}
	productID := &productObjID

	// Create sale using internal model
	var sponsorID primitive.ObjectID
	if client.SponsorID != nil {
		sponsorID = *client.SponsorID
	} else {
		sponsorID = clientID // Use client ID as sponsor if no sponsor
	}

	// Set default status if not provided
	status := "pending"
	if input.Status != nil {
		status = *input.Status
	}

	sale := &models.Sale{
		ID:        saleID,
		ClientID:  clientID,
		SponsorID: sponsorID,
		ProductID: productID,
		Amount:    input.Amount,
		Quantity:  int(input.Quantity),
		Date:      time.Now(),
		Status:    status,
		Note:      input.Note,
	}

	// Update sale using service
	updatedSale, err := r.Resolver.saleService.Update(ctx, id, sale)
	if err != nil {
		return nil, err
	}

	// Convert internal model to GraphQL model
	return &model.Sale{
		ID:        updatedSale.ID.Hex(),
		ClientID:  updatedSale.ClientID.Hex(),
		SponsorID: updatedSale.SponsorID.Hex(),
		ProductID: convertObjectIDToString(updatedSale.ProductID),
		Amount:    updatedSale.Amount,
		Quantity:  int32(updatedSale.Quantity),
		Side:      updatedSale.Side,
		Date:      updatedSale.Date.Format(time.RFC3339),
		Status:    updatedSale.Status,
		Note:      updatedSale.Note,
	}, nil
}

// SaleDelete is the resolver for the saleDelete field.
func (r *mutationResolver) SaleDelete(ctx context.Context, id string) (bool, error) {
	success, err := r.Resolver.saleService.Delete(ctx, id)
	if err != nil {
		return false, err
	}

	return success, nil
}

// PaymentCreate is the resolver for the paymentCreate field.
func (r *mutationResolver) PaymentCreate(ctx context.Context, input model.PaymentInput) (*model.Payment, error) {
	// Convert client ID to ObjectID
	clientID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, fmt.Errorf("invalid client ID: %w", err)
	}

	payment := &models.Payment{
		ClientID:    clientID,
		Amount:      input.Amount,
		Method:      input.Method,
		Description: input.Description,
		Date:        time.Now(),
		Status:      "pending",
	}

	createdPayment, err := r.Resolver.paymentService.Create(ctx, payment)
	if err != nil {
		return nil, err
	}

	return &model.Payment{
		ID:          createdPayment.ID.Hex(),
		ClientID:    createdPayment.ClientID.Hex(),
		Amount:      createdPayment.Amount,
		Method:      createdPayment.Method,
		Date:        createdPayment.Date.Format(time.RFC3339),
		Status:      createdPayment.Status,
		Description: createdPayment.Description,
	}, nil
}

// PaymentUpdate is the resolver for the paymentUpdate field.
func (r *mutationResolver) PaymentUpdate(ctx context.Context, id string, input model.PaymentInput) (*model.Payment, error) {
	// Convert client ID to ObjectID
	clientID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, fmt.Errorf("invalid client ID: %w", err)
	}

	payment := &models.Payment{
		ClientID:    clientID,
		Amount:      input.Amount,
		Method:      input.Method,
		Description: input.Description,
		Date:        time.Now(),
		Status:      "pending",
	}

	updatedPayment, err := r.Resolver.paymentService.Update(ctx, id, payment)
	if err != nil {
		return nil, err
	}

	return &model.Payment{
		ID:          updatedPayment.ID.Hex(),
		ClientID:    updatedPayment.ClientID.Hex(),
		Amount:      updatedPayment.Amount,
		Method:      updatedPayment.Method,
		Date:        updatedPayment.Date.Format(time.RFC3339),
		Status:      updatedPayment.Status,
		Description: updatedPayment.Description,
	}, nil
}

// PaymentDelete is the resolver for the paymentDelete field.
func (r *mutationResolver) PaymentDelete(ctx context.Context, id string) (bool, error) {
	success, err := r.Resolver.paymentService.Delete(ctx, id)
	if err != nil {
		return false, err
	}

	return success, nil
}

// CommissionManualCreate is the resolver for the commissionManualCreate field.
func (r *mutationResolver) CommissionManualCreate(ctx context.Context, input model.CommissionInput) (*model.Commission, error) {
	// Convert IDs to ObjectID
	clientID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, fmt.Errorf("invalid client ID: %w", err)
	}
	sourceClientID, err := primitive.ObjectIDFromHex(input.SourceClientID)
	if err != nil {
		return nil, fmt.Errorf("invalid source client ID: %w", err)
	}

	commission := &models.Commission{
		ClientID:       clientID,
		SourceClientID: sourceClientID,
		Amount:         input.Amount,
		Level:          int(input.Level),
		Type:           input.Type,
		Date:           time.Now(),
	}

	createdCommission, err := r.Resolver.commissionService.Create(ctx, commission)
	if err != nil {
		return nil, err
	}

	return &model.Commission{
		ID:             createdCommission.ID.Hex(),
		ClientID:       createdCommission.ClientID.Hex(),
		SourceClientID: createdCommission.SourceClientID.Hex(),
		Amount:         createdCommission.Amount,
		Level:          int32(createdCommission.Level),
		Type:           createdCommission.Type,
		Date:           createdCommission.Date.Format(time.RFC3339),
	}, nil
}

// RunBinaryCommissionCheck is the resolver for the runBinaryCommissionCheck field.
func (r *mutationResolver) RunBinaryCommissionCheck(ctx context.Context, clientID string) (*model.CommissionResult, error) {
	result, err := r.Resolver.commissionService.RunBinaryCommissionCheck(ctx, clientID)
	if err != nil {
		return nil, err
	}

	return &model.CommissionResult{
		CommissionsCreated: int32(result.CommissionsCreated),
		TotalAmount:        result.TotalAmount,
		Message:            result.Message,
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	// This would typically get the current user from the JWT token
	// For now, return a placeholder
	return &model.User{
		ID:        "admin",
		Email:     "admin@mlm.com",
		Name:      "Admin User",
		Role:      "admin",
		CreatedAt: "",
	}, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.Product, error) {
	// Convert filter and paging to internal models
	var filterModel *models.FilterInput
	if filter != nil {
		// Convert string dates to time.Time
		var dateFrom, dateTo *time.Time
		if filter.DateFrom != nil {
			if t, err := time.Parse(time.RFC3339, *filter.DateFrom); err == nil {
				dateFrom = &t
			}
		}
		if filter.DateTo != nil {
			if t, err := time.Parse(time.RFC3339, *filter.DateTo); err == nil {
				dateTo = &t
			}
		}

		filterModel = &models.FilterInput{
			Search:   filter.Search,
			DateFrom: dateFrom,
			DateTo:   dateTo,
			Status:   filter.Status,
		}
	}

	var pagingModel *models.PagingInput
	if paging != nil {
		// Convert int32 to int
		var page, limit *int
		if paging.Page != nil {
			p := int(*paging.Page)
			page = &p
		}
		if paging.Limit != nil {
			l := int(*paging.Limit)
			limit = &l
		}

		pagingModel = &models.PagingInput{
			Page:  page,
			Limit: limit,
		}
	}

	products, err := r.Resolver.productService.GetAll(ctx, filterModel, pagingModel)
	if err != nil {
		return nil, err
	}

	var result []*model.Product
	for _, product := range products {
		result = append(result, &model.Product{
			ID:          product.ID.Hex(),
			Name:        product.Name,
			Description: product.Description,
			Price:       product.Price,
			Stock:       int32(product.Stock),
			ImageURL:    product.ImageURL,
			CreatedAt:   product.CreatedAt.Format(time.RFC3339),
			UpdatedAt:   product.UpdatedAt.Format(time.RFC3339),
		})
	}

	return result, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id string) (*model.Product, error) {
	product, err := r.Resolver.productService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	return &model.Product{
		ID:          product.ID.Hex(),
		Name:        product.Name,
		Description: product.Description,
		Price:       product.Price,
		Stock:       int32(product.Stock),
		ImageURL:    product.ImageURL,
		CreatedAt:   product.CreatedAt.Format(time.RFC3339),
		UpdatedAt:   product.UpdatedAt.Format(time.RFC3339),
	}, nil
}

// Clients is the resolver for the clients field.
func (r *queryResolver) Clients(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.Client, error) {
	// Convert filter and paging to internal models
	var filterModel *models.FilterInput
	if filter != nil {
		// Convert string dates to time.Time
		var dateFrom, dateTo *time.Time
		if filter.DateFrom != nil {
			if t, err := time.Parse(time.RFC3339, *filter.DateFrom); err == nil {
				dateFrom = &t
			}
		}
		if filter.DateTo != nil {
			if t, err := time.Parse(time.RFC3339, *filter.DateTo); err == nil {
				dateTo = &t
			}
		}

		filterModel = &models.FilterInput{
			Search:   filter.Search,
			DateFrom: dateFrom,
			DateTo:   dateTo,
			Status:   filter.Status,
		}
	}

	var pagingModel *models.PagingInput
	if paging != nil {
		// Convert int32 to int
		var page, limit *int
		if paging.Page != nil {
			p := int(*paging.Page)
			page = &p
		}
		if paging.Limit != nil {
			l := int(*paging.Limit)
			limit = &l
		}

		pagingModel = &models.PagingInput{
			Page:  page,
			Limit: limit,
		}
	}

	clients, err := r.Resolver.clientService.GetAll(ctx, filterModel, pagingModel)
	if err != nil {
		return nil, err
	}

	var result []*model.Client
	for _, client := range clients {
		result = append(result, &model.Client{
			ID:                 client.ID.Hex(),
			ClientID:           client.ClientID,
			Name:               client.Name,
			SponsorID:          convertObjectIDToString(client.SponsorID),
			Position:           client.Position,
			LeftChildID:        convertObjectIDToString(client.LeftChildID),
			RightChildID:       convertObjectIDToString(client.RightChildID),
			JoinDate:           client.JoinDate.Format(time.RFC3339),
			TotalEarnings:      client.TotalEarnings,
			WalletBalance:      client.WalletBalance,
			NetworkVolumeLeft:  client.NetworkVolumeLeft,
			NetworkVolumeRight: client.NetworkVolumeRight,
			BinaryPairs:        int32(client.BinaryPairs),
		})
	}

	return result, nil
}

// Client is the resolver for the client field.
func (r *queryResolver) Client(ctx context.Context, id string) (*model.Client, error) {
	client, err := r.Resolver.clientService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	return &model.Client{
		ID:                 client.ID.Hex(),
		ClientID:           client.ClientID,
		Name:               client.Name,
		SponsorID:          convertObjectIDToString(client.SponsorID),
		Position:           client.Position,
		LeftChildID:        convertObjectIDToString(client.LeftChildID),
		RightChildID:       convertObjectIDToString(client.RightChildID),
		JoinDate:           client.JoinDate.Format(time.RFC3339),
		TotalEarnings:      client.TotalEarnings,
		WalletBalance:      client.WalletBalance,
		NetworkVolumeLeft:  client.NetworkVolumeLeft,
		NetworkVolumeRight: client.NetworkVolumeRight,
		BinaryPairs:        int32(client.BinaryPairs),
	}, nil
}

// Sales is the resolver for the sales field.
func (r *queryResolver) Sales(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.Sale, error) {
	// Convert filter and paging to internal models
	var filterModel *models.FilterInput
	if filter != nil {
		// Convert string dates to time.Time
		var dateFrom, dateTo *time.Time
		if filter.DateFrom != nil {
			if t, err := time.Parse(time.RFC3339, *filter.DateFrom); err == nil {
				dateFrom = &t
			}
		}
		if filter.DateTo != nil {
			if t, err := time.Parse(time.RFC3339, *filter.DateTo); err == nil {
				dateTo = &t
			}
		}

		filterModel = &models.FilterInput{
			Search:   filter.Search,
			DateFrom: dateFrom,
			DateTo:   dateTo,
			Status:   filter.Status,
		}
	}

	var pagingModel *models.PagingInput
	if paging != nil {
		// Convert int32 to int
		var page, limit *int
		if paging.Page != nil {
			p := int(*paging.Page)
			page = &p
		}
		if paging.Limit != nil {
			l := int(*paging.Limit)
			limit = &l
		}

		pagingModel = &models.PagingInput{
			Page:  page,
			Limit: limit,
		}
	}

	sales, err := r.Resolver.saleService.GetAll(ctx, filterModel, pagingModel)
	if err != nil {
		return nil, err
	}

	var result []*model.Sale
	for _, sale := range sales {
		result = append(result, &model.Sale{
			ID:        sale.ID.Hex(),
			ClientID:  sale.ClientID.Hex(),
			SponsorID: sale.SponsorID.Hex(),
			ProductID: convertObjectIDToString(sale.ProductID),
			Amount:    sale.Amount,
			Quantity:  int32(sale.Quantity),
			Side:      sale.Side,
			Date:      sale.Date.Format(time.RFC3339),
			Status:    sale.Status,
			Note:      sale.Note,
		})
	}

	return result, nil
}

// Sale is the resolver for the sale field.
func (r *queryResolver) Sale(ctx context.Context, id string) (*model.Sale, error) {
	sale, err := r.Resolver.saleService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	return &model.Sale{
		ID:        sale.ID.Hex(),
		ClientID:  sale.ClientID.Hex(),
		SponsorID: sale.SponsorID.Hex(),
		ProductID: convertObjectIDToString(sale.ProductID),
		Amount:    sale.Amount,
		Quantity:  int32(sale.Quantity),
		Side:      sale.Side,
		Date:      sale.Date.Format(time.RFC3339),
		Status:    sale.Status,
		Note:      sale.Note,
	}, nil
}

// Payments is the resolver for the payments field.
func (r *queryResolver) Payments(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.Payment, error) {
	// Convert filter and paging to internal models
	var filterModel *models.FilterInput
	if filter != nil {
		// Convert string dates to time.Time
		var dateFrom, dateTo *time.Time
		if filter.DateFrom != nil {
			if t, err := time.Parse(time.RFC3339, *filter.DateFrom); err == nil {
				dateFrom = &t
			}
		}
		if filter.DateTo != nil {
			if t, err := time.Parse(time.RFC3339, *filter.DateTo); err == nil {
				dateTo = &t
			}
		}

		filterModel = &models.FilterInput{
			Search:   filter.Search,
			DateFrom: dateFrom,
			DateTo:   dateTo,
			Status:   filter.Status,
		}
	}

	var pagingModel *models.PagingInput
	if paging != nil {
		// Convert int32 to int
		var page, limit *int
		if paging.Page != nil {
			p := int(*paging.Page)
			page = &p
		}
		if paging.Limit != nil {
			l := int(*paging.Limit)
			limit = &l
		}

		pagingModel = &models.PagingInput{
			Page:  page,
			Limit: limit,
		}
	}

	payments, err := r.Resolver.paymentService.GetAll(ctx, filterModel, pagingModel)
	if err != nil {
		return nil, err
	}

	var result []*model.Payment
	for _, payment := range payments {
		result = append(result, &model.Payment{
			ID:          payment.ID.Hex(),
			ClientID:    payment.ClientID.Hex(),
			Amount:      payment.Amount,
			Method:      payment.Method,
			Date:        payment.Date.Format(time.RFC3339),
			Status:      payment.Status,
			Description: payment.Description,
		})
	}

	return result, nil
}

// Payment is the resolver for the payment field.
func (r *queryResolver) Payment(ctx context.Context, id string) (*model.Payment, error) {
	payment, err := r.Resolver.paymentService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	return &model.Payment{
		ID:          payment.ID.Hex(),
		ClientID:    payment.ClientID.Hex(),
		Amount:      payment.Amount,
		Method:      payment.Method,
		Date:        payment.Date.Format(time.RFC3339),
		Status:      payment.Status,
		Description: payment.Description,
	}, nil
}

// Commissions is the resolver for the commissions field.
func (r *queryResolver) Commissions(ctx context.Context, filter *model.FilterInput, paging *model.PagingInput) ([]*model.Commission, error) {
	// Convert filter and paging to internal models
	var filterModel *models.FilterInput
	if filter != nil {
		// Convert string dates to time.Time
		var dateFrom, dateTo *time.Time
		if filter.DateFrom != nil {
			if t, err := time.Parse(time.RFC3339, *filter.DateFrom); err == nil {
				dateFrom = &t
			}
		}
		if filter.DateTo != nil {
			if t, err := time.Parse(time.RFC3339, *filter.DateTo); err == nil {
				dateTo = &t
			}
		}

		filterModel = &models.FilterInput{
			Search:   filter.Search,
			DateFrom: dateFrom,
			DateTo:   dateTo,
			Status:   filter.Status,
		}
	}

	var pagingModel *models.PagingInput
	if paging != nil {
		// Convert int32 to int
		var page, limit *int
		if paging.Page != nil {
			p := int(*paging.Page)
			page = &p
		}
		if paging.Limit != nil {
			l := int(*paging.Limit)
			limit = &l
		}

		pagingModel = &models.PagingInput{
			Page:  page,
			Limit: limit,
		}
	}

	commissions, err := r.Resolver.commissionService.GetAll(ctx, filterModel, pagingModel)
	if err != nil {
		return nil, err
	}

	var result []*model.Commission
	for _, commission := range commissions {
		result = append(result, &model.Commission{
			ID:             commission.ID.Hex(),
			ClientID:       commission.ClientID.Hex(),
			SourceClientID: commission.SourceClientID.Hex(),
			Amount:         commission.Amount,
			Level:          int32(commission.Level),
			Type:           commission.Type,
			Date:           commission.Date.Format(time.RFC3339),
		})
	}

	return result, nil
}

// Commission is the resolver for the commission field.
func (r *queryResolver) Commission(ctx context.Context, id string) (*model.Commission, error) {
	commission, err := r.Resolver.commissionService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	return &model.Commission{
		ID:             commission.ID.Hex(),
		ClientID:       commission.ClientID.Hex(),
		SourceClientID: commission.SourceClientID.Hex(),
		Amount:         commission.Amount,
		Level:          int32(commission.Level),
		Type:           commission.Type,
		Date:           commission.Date.Format(time.RFC3339),
	}, nil
}

// DashboardStats is the resolver for the dashboardStats field.
func (r *queryResolver) DashboardStats(ctx context.Context, rangeArg *string) (*model.DashboardStats, error) {
	stats, err := r.Resolver.adminService.GetDashboardStats(ctx, rangeArg)
	if err != nil {
		return nil, err
	}

	return &model.DashboardStats{
		TotalProducts:    int32(stats.TotalProducts),
		TotalClients:     int32(stats.TotalClients),
		TotalSales:       stats.TotalSales,
		TotalRevenue:     0,
		ActiveClients:    int32(stats.ActiveClients),
		LeftVolume:       0,
		RightVolume:      0,
		BinaryPairs:      0,
		TotalCommissions: stats.TotalCommissions,
		NetworkBalance:   0,
		MonthlySales:     []*model.MonthlySales{},
		NetworkGrowth:    []*model.NetworkGrowth{},
		SalesStatus:      &model.SalesStatus{Paid: 0, Pending: 0, Partial: 0},
		TopProducts:      []*model.TopProduct{},
		RecentActivity:   []*model.RecentActivity{},
	}, nil
}

// DashboardData is the resolver for the dashboardData field.
func (r *queryResolver) DashboardData(ctx context.Context) (*model.DashboardStats, error) {
	stats, err := r.Resolver.adminService.GetDashboardStats(ctx, nil)
	if err != nil {
		return nil, err
	}

	return &model.DashboardStats{
		TotalProducts:    int32(stats.TotalProducts),
		TotalClients:     int32(stats.TotalClients),
		TotalSales:       stats.TotalSales,
		TotalRevenue:     0,
		ActiveClients:    int32(stats.ActiveClients),
		LeftVolume:       0,
		RightVolume:      0,
		BinaryPairs:      0,
		TotalCommissions: stats.TotalCommissions,
		NetworkBalance:   0,
		MonthlySales:     []*model.MonthlySales{},
		NetworkGrowth:    []*model.NetworkGrowth{},
		SalesStatus:      &model.SalesStatus{Paid: 0, Pending: 0, Partial: 0},
		TopProducts:      []*model.TopProduct{},
		RecentActivity:   []*model.RecentActivity{},
	}, nil
	return &model.DashboardStats{
		TotalProducts:    int32(stats.TotalProducts),
		TotalClients:     int32(stats.TotalClients),
		TotalSales:       stats.TotalSales,
		TotalRevenue:     0,
		ActiveClients:    int32(stats.ActiveClients),
		LeftVolume:       0,
		RightVolume:      0,
		BinaryPairs:      0,
		TotalCommissions: stats.TotalCommissions,
		NetworkBalance:   0,
		MonthlySales:     nil,
		NetworkGrowth:    nil,
		SalesStatus:      nil,
		TopProducts:      nil,
		RecentActivity:   nil,
	}, nil
}

// OnNewSale is the resolver for the onNewSale field.
func (r *subscriptionResolver) OnNewSale(ctx context.Context) (<-chan *model.Sale, error) {
	// Create a channel for the subscription
	saleChan := make(chan *model.Sale, 1)

	// In a real implementation, this would register the channel with a subscription manager
	// For now, we'll just return the channel
	go func() {
		defer close(saleChan)
		// Keep the subscription alive until context is cancelled
		<-ctx.Done()
	}()

	return saleChan, nil
}

// OnNewCommission is the resolver for the onNewCommission field.
func (r *subscriptionResolver) OnNewCommission(ctx context.Context) (<-chan *model.Commission, error) {
	// Create a channel for the subscription
	commissionChan := make(chan *model.Commission, 1)

	// In a real implementation, this would register the channel with a subscription manager
	// For now, we'll just return the channel
	go func() {
		defer close(commissionChan)
		// Keep the subscription alive until context is cancelled
		<-ctx.Done()
	}()

	return commissionChan, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func convertObjectIDToString(objID *primitive.ObjectID) *string {
	if objID == nil {
		return nil
	}
	idStr := objID.Hex()
	return &idStr
}
func (r *Resolver) Client() ClientResolver { return &clientResolver{r} }
func (r *clientResolver) Sponsor(ctx context.Context, obj *model.Client) (*model.Client, error) {
	if obj.SponsorID == nil {
		return nil, nil
	}

	sponsor, err := r.Resolver.clientService.GetByID(ctx, *obj.SponsorID)
	if err != nil {
		return nil, nil // Return nil if sponsor not found
	}

	return &model.Client{
		ID:                 sponsor.ID.Hex(),
		ClientID:           sponsor.ClientID,
		Name:               sponsor.Name,
		SponsorID:          convertObjectIDToString(sponsor.SponsorID),
		Position:           sponsor.Position,
		LeftChildID:        convertObjectIDToString(sponsor.LeftChildID),
		RightChildID:       convertObjectIDToString(sponsor.RightChildID),
		JoinDate:           sponsor.JoinDate.Format(time.RFC3339),
		TotalEarnings:      sponsor.TotalEarnings,
		WalletBalance:      sponsor.WalletBalance,
		NetworkVolumeLeft:  sponsor.NetworkVolumeLeft,
		NetworkVolumeRight: sponsor.NetworkVolumeRight,
		BinaryPairs:        int32(sponsor.BinaryPairs),
	}, nil
}
func (r *clientResolver) LeftChild(ctx context.Context, obj *model.Client) (*model.Client, error) {
	if obj.LeftChildID == nil {
		return nil, nil
	}

	leftChild, err := r.Resolver.clientService.GetByID(ctx, *obj.LeftChildID)
	if err != nil {
		return nil, nil // Return nil if left child not found
	}

	return &model.Client{
		ID:                 leftChild.ID.Hex(),
		ClientID:           leftChild.ClientID,
		Name:               leftChild.Name,
		SponsorID:          convertObjectIDToString(leftChild.SponsorID),
		Position:           leftChild.Position,
		LeftChildID:        convertObjectIDToString(leftChild.LeftChildID),
		RightChildID:       convertObjectIDToString(leftChild.RightChildID),
		JoinDate:           leftChild.JoinDate.Format(time.RFC3339),
		TotalEarnings:      leftChild.TotalEarnings,
		WalletBalance:      leftChild.WalletBalance,
		NetworkVolumeLeft:  leftChild.NetworkVolumeLeft,
		NetworkVolumeRight: leftChild.NetworkVolumeRight,
		BinaryPairs:        int32(leftChild.BinaryPairs),
	}, nil
}
func (r *clientResolver) RightChild(ctx context.Context, obj *model.Client) (*model.Client, error) {
	if obj.RightChildID == nil {
		return nil, nil
	}

	rightChild, err := r.Resolver.clientService.GetByID(ctx, *obj.RightChildID)
	if err != nil {
		return nil, nil // Return nil if right child not found
	}

	return &model.Client{
		ID:                 rightChild.ID.Hex(),
		ClientID:           rightChild.ClientID,
		Name:               rightChild.Name,
		SponsorID:          convertObjectIDToString(rightChild.SponsorID),
		Position:           rightChild.Position,
		LeftChildID:        convertObjectIDToString(rightChild.LeftChildID),
		RightChildID:       convertObjectIDToString(rightChild.RightChildID),
		JoinDate:           rightChild.JoinDate.Format(time.RFC3339),
		TotalEarnings:      rightChild.TotalEarnings,
		WalletBalance:      rightChild.WalletBalance,
		NetworkVolumeLeft:  rightChild.NetworkVolumeLeft,
		NetworkVolumeRight: rightChild.NetworkVolumeRight,
		BinaryPairs:        int32(rightChild.BinaryPairs),
	}, nil
}
type clientResolver struct{ *Resolver }
*/
